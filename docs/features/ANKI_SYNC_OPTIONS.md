# Варианты реализации сервера синхронизации Anki

## Текущая ситуация

✅ **Что уже сделано:**
- Создано Django приложение `anki_sync` с базовой структурой
- Модели для хранения данных синхронизации
- Базовые endpoints для обработки запросов (`/sync/`)
- Интеграция с созданием колод (автоматический вызов импорта)
- Миграции применены

❌ **Что не реализовано:**
- Полный протокол синхронизации Anki
- Импорт .apkg файлов в SQLite базу Anki
- Аутентификация через HTTP Basic Auth
- Синхронизация медиафайлов
- Обработка конфликтов синхронизации

## Варианты дальнейших действий

### Вариант 1: Использование готового сервера синхронизации (Рекомендуется)

**Описание:**
Использовать готовый сервер синхронизации Anki (Python или Rust версия) как отдельный сервис и интегрировать его с Django.

**Преимущества:**
- ✅ Полная совместимость с протоколом Anki
- ✅ Минимальные затраты времени на разработку
- ✅ Проверенное решение
- ✅ Автоматическая поддержка новых версий Anki

**Недостатки:**
- ⚠️ Требует запуска отдельного сервиса
- ⚠️ Нужна интеграция с Django (общее хранилище пользователей)

**Реализация:**

#### 1.1. Python версия (anki.syncserver)

```bash
# Установка
pip install anki

# Запуск сервера
SYNC_USER1=username:password python -m anki.syncserver
```

**Интеграция с Django:**
- Запускать сервер синхронизации как отдельный процесс
- Использовать общую базу пользователей Django
- Настроить общее хранилище данных (`SYNC_BASE`)

**Сложность:** ⭐⭐ (Средняя)
**Время:** 2-4 часа
**Риски:** Низкие

#### 1.2. Rust версия (Docker)

```bash
# Использование готового Docker образа
docker run \
    --publish 8080:8080 \
    --volume ./sync_data:/syncserver \
    ghcr.io/yangchuansheng/anki-sync-server:latest
```

**Интеграция с Django:**
- Запускать в Docker контейнере
- Настроить reverse proxy (nginx) для маршрутизации
- Использовать общее хранилище

**Сложность:** ⭐⭐ (Средняя)
**Время:** 3-5 часов
**Риски:** Низкие

---

### Вариант 2: Реализация протокола синхронизации с нуля

**Описание:**
Изучить исходный код Anki и реализовать полный протокол синхронизации в Django.

**Преимущества:**
- ✅ Полный контроль над процессом
- ✅ Интеграция с существующей системой пользователей
- ✅ Гибкость в настройке

**Недостатки:**
- ❌ Очень высокая сложность
- ❌ Требует глубокого изучения протокола
- ❌ Риск несовместимости с новыми версиями Anki
- ❌ Много времени на разработку и тестирование

**Что нужно изучить:**
1. Исходный код Anki: https://github.com/ankitects/anki
2. Протокол синхронизации (rslib/src/sync/)
3. Структуру SQLite базы Anki
4. Формат запросов/ответов

**Основные методы протокола:**
- `meta` - получение метаданных
- `start` - начало синхронизации
- `applyGraves` - применение удалений
- `applyChanges` - применение изменений
- `chunk` - получение чанка данных
- `applyChunk` - применение чанка
- `sanitize` - санитизация данных
- `mediaChanges` - изменения медиа
- `uploadChanges` - загрузка изменений

**Сложность:** ⭐⭐⭐⭐⭐ (Очень высокая)
**Время:** 40-80 часов
**Риски:** Высокие (несовместимость, баги)

---

### Вариант 3: Гибридный подход (Упрощенная синхронизация)

**Описание:**
Использовать библиотеку `anki` для импорта .apkg файлов в SQLite базу, но не реализовывать полный протокол синхронизации. Вместо этого использовать упрощенный подход.

**Преимущества:**
- ✅ Автоматический импорт колод при создании
- ✅ Работа с реальной базой данных Anki
- ✅ Возможность расширения в будущем

**Недостатки:**
- ⚠️ Не полная синхронизация (только импорт)
- ⚠️ Пользователю нужно вручную синхронизировать через AnkiWeb или другой сервер

**Реализация:**

```python
# Установка библиотеки anki
pip install anki

# Импорт .apkg в коллекцию
from anki.collection import Collection
from anki.importing import AnkiPackageImporter

def import_apkg_to_anki_collection(user, apkg_path):
    collection_path = get_user_collection_path(user)
    col = Collection(collection_path)
    
    # Импортируем .apkg
    importer = AnkiPackageImporter(col, str(apkg_path))
    importer.run()
    
    col.close()
```

**Сценарий использования:**
1. Пользователь создает колоду в веб-приложении
2. Колода автоматически импортируется в его SQLite базу на сервере
3. Пользователь настраивает Anki на синхронизацию с AnkiWeb
4. При синхронизации колода попадает в AnkiWeb
5. Мобильное приложение синхронизируется с AnkiWeb и получает колоду

**Сложность:** ⭐⭐⭐ (Средняя-высокая)
**Время:** 8-12 часов
**Риски:** Средние

---

### Вариант 4: Использование AnkiConnect + кастомная синхронизация

**Описание:**
Использовать AnkiConnect для работы с локальной базой Anki и создать собственную систему синхронизации через API.

**Преимущества:**
- ✅ Простой API для работы с Anki
- ✅ Не требует знания протокола синхронизации
- ✅ Гибкость в реализации

**Недостатки:**
- ❌ AnkiConnect работает только локально
- ❌ Нужна собственная система синхронизации
- ❌ Не совместимо с официальным протоколом Anki

**Сложность:** ⭐⭐⭐⭐ (Высокая)
**Время:** 20-30 часов
**Риски:** Средние-высокие

---

## Рекомендации

### Для быстрого результата: Вариант 1.1 (Python syncserver)

**План действий:**
1. Установить библиотеку `anki`
2. Настроить запуск `anki.syncserver` как отдельного процесса
3. Интегрировать с системой пользователей Django
4. Настроить общее хранилище данных
5. Протестировать с реальными клиентами Anki

**Оценка времени:** 2-4 часа
**Сложность:** Средняя

### Для долгосрочного решения: Вариант 1.2 (Rust syncserver в Docker)

**План действий:**
1. Настроить Docker контейнер с Rust сервером
2. Настроить nginx для маршрутизации запросов
3. Интегрировать с Django (общие пользователи)
4. Настроить мониторинг и логирование

**Оценка времени:** 3-5 часов
**Сложность:** Средняя

### Для минимальной реализации: Вариант 3 (Гибридный)

**План действий:**
1. Установить библиотеку `anki`
2. Реализовать импорт .apkg в SQLite базу
3. Предоставить инструкции пользователям по настройке синхронизации
4. В будущем можно расширить до полного протокола

**Оценка времени:** 8-12 часов
**Сложность:** Средняя-высокая

---

## Сравнительная таблица

| Вариант | Сложность | Время | Риски | Совместимость | Рекомендация |
|---------|-----------|------|-------|---------------|--------------|
| 1.1 Python syncserver | ⭐⭐ | 2-4ч | Низкие | ✅ Полная | ⭐⭐⭐⭐⭐ |
| 1.2 Rust syncserver | ⭐⭐ | 3-5ч | Низкие | ✅ Полная | ⭐⭐⭐⭐ |
| 2. С нуля | ⭐⭐⭐⭐⭐ | 40-80ч | Высокие | ⚠️ Неизвестна | ⭐ |
| 3. Гибридный | ⭐⭐⭐ | 8-12ч | Средние | ⚠️ Частичная | ⭐⭐⭐ |
| 4. AnkiConnect | ⭐⭐⭐⭐ | 20-30ч | Средние | ❌ Нет | ⭐⭐ |

---

## Следующие шаги (рекомендуемый путь)

### Этап 1: Быстрый прототип (Вариант 1.1)

1. **Установить библиотеку anki:**
   ```bash
   cd backend
   source venv/bin/activate
   pip install anki
   ```

2. **Изучить работу anki.syncserver:**
   - Запустить локально
   - Протестировать с клиентом Anki
   - Понять структуру данных

3. **Интегрировать с Django:**
   - Настроить запуск как отдельный процесс
   - Использовать пользователей Django для аутентификации
   - Настроить общее хранилище

### Этап 2: Реализация импорта (Вариант 3)

1. **Реализовать импорт .apkg:**
   ```python
   from anki.collection import Collection
   from anki.importing import AnkiPackageImporter
   
   def import_apkg_to_anki_collection(user, apkg_path):
       collection_path = get_user_collection_path(user)
       col = Collection(collection_path)
       importer = AnkiPackageImporter(col, str(apkg_path))
       importer.run()
       col.close()
   ```

2. **Протестировать импорт:**
   - Создать колоду
   - Проверить импорт в базу
   - Убедиться, что данные корректны

### Этап 3: Продакшн (Вариант 1.2)

1. **Настроить Docker контейнер:**
   - Использовать готовый образ
   - Настроить volumes для данных
   - Настроить сеть

2. **Настроить nginx:**
   - Reverse proxy для синхронизации
   - HTTPS
   - Логирование

3. **Мониторинг:**
   - Логи синхронизации
   - Метрики использования
   - Алерты

---

## Технические детали

### Структура протокола синхронизации Anki

Anki использует HTTP POST запросы с JSON телом:

```json
{
  "method": "meta",
  "params": {
    "client": "anki",
    "ver": 11,
    "min": 11
  }
}
```

Ответ:
```json
{
  "scm": 1234567890,
  "ts": 1234567890,
  "mod": 1234567890,
  "usn": 0,
  "musn": 0,
  "msg": "",
  "cont": false
}
```

### Структура SQLite базы Anki

Основная таблица `col` содержит:
- `crt` - creation time
- `mod` - modification time
- `scm` - schema modification time
- `ver` - version
- `usn` - update sequence number
- `conf` - конфигурация (JSON)
- `models` - модели карточек (JSON)
- `decks` - колоды (JSON)
- `tags` - теги (JSON)

### Аутентификация

Anki использует HTTP Basic Authentication:
```
Authorization: Basic base64(username:password)
```

---

## Вывод

**Рекомендуемый путь:** Начать с Варианта 1.1 (Python syncserver), затем перейти к Варианту 1.2 (Rust в Docker) для продакшена.

Это обеспечит:
- ✅ Быструю реализацию
- ✅ Полную совместимость
- ✅ Минимальные риски
- ✅ Возможность расширения

