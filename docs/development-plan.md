# Детальный поэтапный план разработки Anki Card Generator

## Общая информация

Этот документ описывает детальный план разработки приложения для генерации карточек Anki. План разбит на 13 этапов, каждый из которых содержит конкретные задачи и критерии завершения.

**Обновлено:** 
- 13 ноября 2024 - добавлены этапы 9-12 с новыми требованиями (мультиязычность, упрощенный режим, улучшения генерации медиа).
- 13 ноября 2024 - добавлен этап 13 с системой токенов для контроля генерации карточек.

---

## Этап 1: Настройка проекта и инфраструктуры

**Цель:** Создать базовую структуру проекта, настроить окружение разработки и необходимые инструменты.

### Задачи

#### 1.1. Инициализация проекта
- [ ] Создать структуру директорий проекта
- [ ] Инициализировать Git репозиторий
- [ ] Создать `.gitignore` для Python и Node.js
- [ ] Создать базовый `README.md`

#### 1.2. Настройка Backend (Django)
- [ ] Создать виртуальное окружение Python
- [ ] Установить Django 4.x
- [ ] Создать Django проект (`django-admin startproject config`)
- [ ] Настроить структуру приложений (`apps/users`, `apps/words`, `apps/cards`)
- [ ] Создать `requirements.txt` с базовыми зависимостями
- [ ] Настроить `settings.py`:
  - [ ] Подключение к PostgreSQL
  - [ ] Настройка Django REST Framework
  - [ ] Настройка CORS
  - [ ] Настройка MEDIA_ROOT и MEDIA_URL
  - [ ] Загрузка переменных окружения через `python-dotenv`

#### 1.3. Настройка базы данных
- [ ] Установить и настроить PostgreSQL
- [ ] Создать базу данных `anki_db`
- [ ] Настроить подключение в `settings.py`
- [ ] Протестировать подключение

#### 1.4. Настройка Frontend (React)
- [ ] Создать React приложение с TypeScript (`npx create-react-app frontend --template typescript`)
- [ ] Установить и настроить TailwindCSS
- [ ] Установить Axios для HTTP-запросов
- [ ] Настроить структуру папок (`components/`, `services/`, `types/`)
- [ ] Создать базовый `App.tsx`
- [ ] Настроить `package.json` с необходимыми зависимостями

#### 1.5. Настройка переменных окружения
- [ ] Создать `.env.example` с примерами переменных
- [ ] Создать `.env` для разработки
- [ ] Настроить переменные:
  - `DATABASE_URL`
  - `SECRET_KEY`
  - `DEBUG`
  - `ALLOWED_HOSTS`
  - `CORS_ALLOWED_ORIGINS`

### Критерии завершения этапа
- ✅ Проект успешно запускается локально
- ✅ Backend отвечает на запросы (проверка через `/admin`)
- ✅ Frontend запускается и отображает базовую страницу
- ✅ База данных подключена и работает
- ✅ Все зависимости установлены

**Ориентировочное время:** 1-2 дня

---

## Этап 2: Backend - Модели данных и аутентификация

**Цель:** Создать модели базы данных, систему аутентификации и базовые API endpoints.

### Задачи

#### 2.1. Модель User
- [ ] Создать приложение `apps/users`
- [ ] Расширить стандартную модель User Django:
  - [ ] Добавить поле `preferred_language` (CharField, choices: 'pt', 'de')
  - [ ] Добавить поле `created_at` (DateTimeField, auto_now_add)
- [ ] Создать миграции
- [ ] Применить миграции

#### 2.2. Модель Word
- [ ] Создать приложение `apps/words`
- [ ] Создать модель `Word`:
  - [ ] `user` (ForeignKey к User)
  - [ ] `original_word` (CharField, max_length=200)
  - [ ] `translation` (CharField, max_length=200)
  - [ ] `language` (CharField, choices: 'pt', 'de')
  - [ ] `audio_file` (FileField, null=True, blank=True)
  - [ ] `image_file` (ImageField, null=True, blank=True)
  - [ ] `created_at` (DateTimeField, auto_now_add)
  - [ ] `updated_at` (DateTimeField, auto_now)
- [ ] Добавить уникальный индекс `(user, original_word, language)`
- [ ] Создать миграции
- [ ] Применить миграции

#### 2.3. Система аутентификации
- [ ] Установить и настроить `djangorestframework-simplejwt` (или использовать токены DRF)
- [ ] Создать сериализаторы:
  - [ ] `UserRegistrationSerializer`
  - [ ] `UserLoginSerializer`
  - [ ] `UserProfileSerializer`
- [ ] Создать ViewSets/Views:
  - [ ] `RegisterView` (POST `/api/auth/register/`)
  - [ ] `LoginView` (POST `/api/auth/login/`)
  - [ ] `UserProfileView` (GET/PATCH `/api/user/profile/`)
- [ ] Настроить URL-маршруты
- [ ] Добавить проверку аутентификации для защищенных endpoints

#### 2.4. API для работы со словами (базовый)
- [ ] Создать сериализатор `WordSerializer`
- [ ] Создать ViewSet для списка слов:
  - [ ] `GET /api/words/list/` — список всех слов пользователя
  - [ ] Фильтрация по `language` (query param)
  - [ ] Поиск по `original_word` и `translation` (query param `search`)
- [ ] Настроить пагинацию (опционально)
- [ ] Добавить фильтрацию по текущему пользователю

#### 2.5. Тестирование API
- [ ] Протестировать регистрацию через Postman/curl
- [ ] Протестировать вход и получение токена
- [ ] Протестировать получение профиля
- [ ] Протестировать список слов (с аутентификацией)

### Критерии завершения этапа
- ✅ Модели созданы и применены в БД
- ✅ Регистрация и вход работают
- ✅ API возвращает корректные данные
- ✅ Аутентификация защищает endpoints
- ✅ Все запросы протестированы

**Ориентировочное время:** 2-3 дня

---

## Этап 3: Backend - Генерация карточек Anki

**Цель:** Реализовать логику генерации `.apkg` файлов с использованием библиотеки `genanki`.

### Задачи

#### 3.1. Установка и изучение genanki
- [ ] Установить библиотеку `genanki`
- [ ] Изучить документацию и примеры
- [ ] Создать тестовый скрипт для генерации простой колоды

#### 3.2. Создание приложения cards
- [ ] Создать приложение `apps/cards`
- [ ] Создать утилиты для работы с genanki:
  - [ ] Функция создания модели карточек (Model)
  - [ ] Функция создания колоды (Deck)
  - [ ] Функция добавления записей (Notes)

#### 3.3. Логика генерации .apkg
- [ ] Создать функцию `generate_apkg()`:
  - [ ] Принимает список слов, переводы, медиафайлы, название колоды
  - [ ] Создает модель карточек (двусторонние)
  - [ ] Создает колоду с указанным названием
  - [ ] Добавляет записи для каждого слова
  - [ ] Упаковывает медиафайлы
  - [ ] Генерирует `.apkg` файл
  - [ ] Сохраняет файл во временное хранилище
  - [ ] Возвращает путь к файлу и UUID

#### 3.4. API для генерации карточек
- [ ] Создать сериализатор `CardGenerationSerializer`:
  - [ ] `words` (строка через запятую)
  - [ ] `language` (pt/de)
  - [ ] `translations` (JSON объект)
  - [ ] `audio_files` (JSON объект, опционально)
  - [ ] `image_files` (JSON объект, опционально)
  - [ ] `deck_name` (строка)
- [ ] Создать View `GenerateCardsView`:
  - [ ] Валидация входных данных
  - [ ] Парсинг списка слов
  - [ ] Проверка на дубликаты в БД
  - [ ] Сохранение новых слов в БД
  - [ ] Вызов функции генерации `.apkg`
  - [ ] Возврат ссылки на скачивание
- [ ] Создать View `DownloadCardsView`:
  - [ ] Получение файла по UUID
  - [ ] Отправка файла пользователю
  - [ ] Очистка старых файлов (опционально)

#### 3.5. Обработка медиафайлов
- [ ] Настроить загрузку файлов через Django
- [ ] Создать функции для валидации:
  - [ ] Аудио: только MP3, проверка размера
  - [ ] Изображения: только JPG/PNG, проверка размера
- [ ] Создать функции для сохранения:
  - [ ] Генерация уникальных имен файлов (UUID)
  - [ ] Сохранение в `MEDIA_ROOT`
  - [ ] Возврат путей для использования в genanki

#### 3.6. Сохранение слов в БД
- [ ] При генерации карточек сохранять все слова в модель `Word`
- [ ] Проверка на дубликаты перед сохранением
- [ ] Если слово уже существует — использовать существующую запись
- [ ] Обновление `updated_at` при повторном использовании

#### 3.7. Тестирование генерации
- [ ] Протестировать генерацию простой колоды (без медиа)
- [ ] Протестировать генерацию с аудио
- [ ] Протестировать генерацию с изображениями
- [ ] Протестировать генерацию с обоими типами медиа
- [ ] Проверить импорт `.apkg` в Anki Desktop
- [ ] Проверить корректность двусторонних карточек

### Критерии завершения этапа
- ✅ `.apkg` файлы генерируются корректно
- ✅ Файлы успешно импортируются в Anki
- ✅ Двусторонние карточки работают правильно
- ✅ Медиафайлы включаются в колоду
- ✅ Слова сохраняются в БД
- ✅ API endpoints работают и протестированы

**Ориентировочное время:** 3-4 дня

---

## Этап 4: Frontend - Базовый интерфейс

**Цель:** Создать базовый пользовательский интерфейс для ввода данных и генерации карточек.

### Задачи

#### 4.1. Настройка API клиента
- [ ] Создать файл `src/services/api.ts`
- [ ] Настроить базовый URL для Axios
- [ ] Настроить interceptors для добавления токена аутентификации
- [ ] Создать функции для API запросов:
  - [ ] `register()`
  - [ ] `login()`
  - [ ] `getProfile()`
  - [ ] `updateProfile()`
  - [ ] `getWordsList()`
  - [ ] `generateCards()`
  - [ ] `downloadCards()`

#### 4.2. Типы TypeScript
- [ ] Создать файл `src/types/index.ts`
- [ ] Определить типы:
  - [ ] `User`
  - [ ] `Word`
  - [ ] `CardGenerationRequest`
  - [ ] `CardGenerationResponse`
  - [ ] `Language` ('pt' | 'de')

#### 4.3. Компонент аутентификации
- [ ] Создать компонент `LoginForm.tsx`:
  - [ ] Поля: username, password
  - [ ] Валидация формы
  - [ ] Обработка ошибок
  - [ ] Сохранение токена в localStorage
- [ ] Создать компонент `RegisterForm.tsx`:
  - [ ] Поля: username, email, password, preferred_language
  - [ ] Валидация формы
  - [ ] Обработка ошибок
- [ ] Создать контекст `AuthContext` для управления состоянием аутентификации

#### 4.4. Компонент WordInput
- [ ] Создать компонент `WordInput.tsx`:
  - [ ] Текстовое поле для ввода слов через запятую
  - [ ] Валидация ввода (не пустое, минимум одно слово)
  - [ ] Отображение списка введенных слов
  - [ ] Возможность удаления слов из списка
  - [ ] Подсветка валидных/невалидных слов

#### 4.5. Компонент LanguageSelector
- [ ] Создать компонент `LanguageSelector.tsx`:
  - [ ] Выпадающий список (select) с опциями 'pt' и 'de'
  - [ ] Загрузка `preferred_language` из профиля пользователя
  - [ ] Сохранение выбора в профиле при изменении
  - [ ] Отображение названий языков на русском

#### 4.6. Компонент для ввода переводов
- [ ] Создать компонент `TranslationInput.tsx`:
  - [ ] Динамический список полей для каждого слова
  - [ ] Поле ввода перевода для каждого слова
  - [ ] Валидация (обязательное поле)
  - [ ] Отображение исходного слова рядом с полем перевода

#### 4.7. Компонент GenerateButton
- [ ] Создать компонент `GenerateButton.tsx`:
  - [ ] Кнопка "Сгенерировать карточки"
  - [ ] Индикатор загрузки (disabled во время генерации)
  - [ ] Обработка успешного ответа
  - [ ] Автоматическое скачивание файла
  - [ ] Обработка ошибок с отображением сообщений

#### 4.8. Главный компонент App
- [ ] Создать структуру `App.tsx`:
  - [ ] Проверка аутентификации
  - [ ] Роутинг (Login/Register/Main)
  - [ ] Интеграция всех компонентов
  - [ ] Обработка состояния загрузки
  - [ ] Обработка ошибок

#### 4.9. Базовые стили
- [ ] Настроить TailwindCSS
- [ ] Создать базовые стили для форм
- [ ] Создать стили для кнопок
- [ ] Создать стили для индикаторов загрузки
- [ ] Адаптивный дизайн (базовый)

### Критерии завершения этапа
- ✅ Пользователь может зарегистрироваться и войти
- ✅ Пользователь может ввести слова и выбрать язык
- ✅ Пользователь может ввести переводы
- ✅ Пользователь может сгенерировать карточки
- ✅ Файл автоматически скачивается
- ✅ Базовые стили применены

**Ориентировочное время:** 3-4 дня

---

## Этап 5: Backend - Интеграция OpenAI API для генерации медиа

**Цель:** Реализовать автоматическую генерацию изображений и аудио через OpenAI API.

### Задачи

#### 5.1. Установка и настройка OpenAI SDK
- [ ] Установить библиотеку `openai` (версия 1.12.0+)
- [ ] Добавить `OPENAI_API_KEY` в переменные окружения
- [ ] Создать утилиту для инициализации OpenAI клиента
- [ ] Настроить обработку ошибок API

#### 5.2. Генерация изображений через DALL-E 3
- [ ] Создать функцию `generate_image_with_dalle()`:
  - [ ] Принимает слово, перевод, язык
  - [ ] Формирует промпт для генерации изображения (например: "A simple, clear illustration of [word] ([translation] in Russian)")
  - [ ] Вызывает OpenAI DALL-E 3 API (`dall-e-3` модель)
  - [ ] Сохраняет изображение локально с уникальным именем (UUID)
  - [ ] Возвращает путь к сохраненному файлу
- [ ] Обработка ошибок API (rate limits, invalid requests)
- [ ] Валидация размера и формата полученного изображения

#### 5.3. Генерация аудио через TTS-1-HD
- [ ] Создать функцию `generate_audio_with_tts()`:
  - [ ] Принимает слово и язык
  - [ ] Определяет голос в зависимости от языка (pt → португальский голос, de → немецкий голос)
  - [ ] Вызывает OpenAI TTS API (`tts-1-hd` модель)
  - [ ] Сохраняет аудио в формате MP3 с уникальным именем (UUID)
  - [ ] Возвращает путь к сохраненному файлу
- [ ] Обработка ошибок API
- [ ] Валидация формата и качества аудио

#### 5.4. API endpoints для генерации медиа
- [ ] Создать приложение `apps/media` (или добавить в `apps/cards`)
- [ ] Создать сериализаторы:
  - [ ] `ImageGenerationSerializer` (word, translation, language)
  - [ ] `AudioGenerationSerializer` (word, language)
- [ ] Создать Views:
  - [ ] `GenerateImageView` (POST `/api/media/generate-image/`)
  - [ ] `GenerateAudioView` (POST `/api/media/generate-audio/`)
- [ ] Добавить аутентификацию для endpoints
- [ ] Настроить URL-маршруты

#### 5.5. API endpoints для загрузки собственных медиа
- [ ] Создать сериализаторы:
  - [ ] `ImageUploadSerializer` (file field)
  - [ ] `AudioUploadSerializer` (file field)
- [ ] Создать Views:
  - [ ] `UploadImageView` (POST `/api/media/upload-image/`)
  - [ ] `UploadAudioView` (POST `/api/media/upload-audio/`)
- [ ] Валидация форматов файлов:
  - [ ] Изображения: только JPG, PNG (максимум 10MB)
  - [ ] Аудио: только MP3 (максимум 5MB)
- [ ] Сохранение файлов с уникальными именами
- [ ] Возврат URL к загруженному файлу

#### 5.6. Обновление модели Word
- [ ] Добавить поля для хранения ID сгенерированных медиа (опционально):
  - [ ] `generated_image_id` (CharField, null=True)
  - [ ] `generated_audio_id` (CharField, null=True)
- [ ] Или использовать существующие поля `image_file` и `audio_file`

#### 5.7. Тестирование генерации медиа
- [ ] Протестировать генерацию изображений для разных слов
- [ ] Протестировать генерацию аудио для разных языков
- [ ] Протестировать обработку ошибок API
- [ ] Протестировать загрузку собственных файлов
- [ ] Проверить качество сгенерированных медиафайлов

### Критерии завершения этапа
- ✅ OpenAI API интегрирован и работает
- ✅ Изображения генерируются через DALL-E 3
- ✅ Аудио генерируется через TTS-1-HD
- ✅ Пользователь может загружать собственные медиафайлы
- ✅ Все API endpoints протестированы
- ✅ Обработка ошибок реализована

**Ориентировочное время:** 3-4 дня

---

## Этап 6: Frontend - Генерация и управление медиафайлами

**Цель:** Создать пользовательский интерфейс для генерации и управления медиафайлами через OpenAI API.

### Задачи

#### 6.1. Компонент MediaGenerator
- [x] Создать компонент `MediaGenerator.tsx`:
  - [x] Принимает слово, перевод, язык как props
  - [x] Отображает кнопки "Добавить картинку" и "Добавить аудио"
  - [x] Интеграция с API для генерации медиа
  - [x] Индикатор загрузки при генерации
  - [x] Предпросмотр сгенерированных/загруженных медиафайлов
  - [x] Кнопка "Перегенерировать" для каждого медиафайла
  - [x] Кнопка "Загрузить свой вариант" для каждого медиафайла

#### 6.2. Компонент для загрузки собственных файлов
- [x] Создать компонент `FileUpload.tsx`:
  - [x] Поле для загрузки файла (input type="file")
  - [x] Валидация формата и размера на клиенте
  - [x] Предпросмотр загруженного файла
  - [x] Отображение имени файла
  - [x] Возможность удалить загруженный файл
  - [x] Интеграция с API для загрузки

#### 6.3. Интеграция MediaGenerator в форму
- [x] Добавить `MediaGenerator` для каждого слова в списке
- [x] Сохранять состояние медиафайлов (сгенерированных/загруженных) в состоянии формы
- [x] Передавать медиафайлы в API при генерации карточек
- [x] Отображать статус медиафайлов (нет, генерируется, готово)

#### 6.4. Обновление API клиента
- [x] Добавить функции в `src/services/api.ts`:
  - [x] `generateImage(word, translation, language)`
  - [x] `generateAudio(word, language)`
  - [x] `uploadImage(file)`
  - [x] `uploadAudio(file)`
- [x] Обработка ошибок API
- [x] Обработка успешных ответов

#### 6.5. Улучшение UX
- [x] Добавить toast-уведомления для успешной генерации/загрузки
- [x] Показывать прогресс генерации (индикатор загрузки)
- [x] Блокировать кнопки во время генерации
- [x] Добавить анимации для предпросмотра медиа
- [x] Улучшить визуальное отображение медиафайлов

#### 6.6. Улучшение отображения ошибок
- [x] Отображать ошибки генерации медиа
- [x] Отображать ошибки загрузки файлов
- [x] Предлагать варианты решения (повторить попытку, загрузить свой файл)

#### 6.7. Исправление передачи медиафайлов
- [x] Исправлена передача медиафайлов из frontend в backend
- [x] Исправлена логика сохранения медиафайлов в состоянии
- [x] Медиафайлы корректно добавляются в .apkg файлы

### Критерии завершения этапа
- ✅ Пользователь может генерировать изображения через OpenAI
- ✅ Пользователь может генерировать аудио через OpenAI
- ✅ Пользователь может перегенерировать медиафайлы
- ✅ Пользователь может загружать собственные медиафайлы
- ✅ Предпросмотр медиафайлов работает корректно
- ✅ Интерфейс удобен и интуитивен
- ✅ Медиафайлы корректно передаются из frontend в backend
- ✅ Медиафайлы корректно добавляются в .apkg файлы

**Статус:** ✅ Завершен (13 ноября 2024)

---

## Этап 9: Профиль пользователя и мультиязычность

**Цель:** Создать расширенный профиль пользователя с настройками языков, личными данными и редактируемыми промптами.

### Задачи

#### 9.1. Расширение модели User
- [ ] Добавить поля в модель User:
  - [ ] `first_name` (CharField, max_length=100)
  - [ ] `last_name` (CharField, max_length=100)
  - [ ] `avatar` (ImageField, null=True, blank=True)
  - [ ] `native_language` (CharField, choices, default='ru')
  - [ ] `learning_language` (CharField, choices, default='pt')
  - [ ] `theme` (CharField, choices: 'light'|'dark', default='light')
- [ ] Создать миграции
- [ ] Обновить сериализаторы

#### 9.2. Модель для промптов пользователя
- [ ] Создать модель `UserPrompt`:
  - [ ] `user` (ForeignKey к User)
  - [ ] `prompt_type` (CharField: 'image', 'audio', 'word_analysis', 'translation')
  - [ ] `custom_prompt` (TextField) - редактируемый промпт пользователя
  - [ ] `is_custom` (BooleanField, default=False)
  - [ ] `created_at`, `updated_at`
- [ ] Создать миграции
- [ ] Создать API для управления промптами

#### 9.3. Страница профиля (Frontend)
- [ ] Создать компонент `ProfilePage.tsx`
- [ ] Раздел "Личные данные":
  - [ ] Поле "Имя"
  - [ ] Поле "Фамилия"
  - [ ] Загрузка фото профиля
  - [ ] Предпросмотр фото
- [ ] Раздел "Настройки языков":
  - [ ] Выбор основного языка (родного)
  - [ ] Выбор языка изучения
  - [ ] Отображение флага страны изучаемого языка
- [ ] Раздел "Визуальные настройки":
  - [ ] Переключатель темы (светлая/темная)
- [ ] Раздел "Настройка промптов":
  - [ ] Редактируемые поля для каждого типа промпта
  - [ ] Кнопка "Сбросить до заводских настроек"
  - [ ] Отображение промптов на родном языке пользователя

#### 9.4. API для профиля
- [ ] `GET /api/user/profile/` - получение профиля
- [ ] `PATCH /api/user/profile/` - обновление профиля
- [ ] `GET /api/user/prompts/` - получение промптов
- [ ] `PATCH /api/user/prompts/{type}/` - обновление промпта
- [ ] `POST /api/user/prompts/{type}/reset/` - сброс промпта

#### 9.5. Интеграция с интерфейсом
- [ ] Убрать переключатель языка на странице создания карточек
- [ ] Язык изучения берется из профиля (read-only отображение)
- [ ] Применение темы ко всему приложению
- [ ] Использование промптов пользователя при генерации медиа

### Критерии завершения этапа
- ✅ Пользователь может редактировать свой профиль
- ✅ Пользователь может выбирать основной язык и язык изучения
- ✅ Пользователь может редактировать промпты
- ✅ Промпты используются при генерации медиа
- ✅ Тема применяется ко всему приложению

**Ориентировочное время:** 4-5 дней

---

## Этап 10: Улучшение ввода слов и анализ смешанных языков

**Цель:** Улучшить парсинг ввода слов, добавить анализ смешанных языков и автоматический перевод.

### Задачи

#### 10.1. Улучшение парсинга ввода
- [ ] Обновить логику парсинга в `WordInput`:
  - [ ] Запятая разделяет слова/словосочетания
  - [ ] Словосочетания определяются по заглавной букве первого слова
  - [ ] Точки игнорируются
  - [ ] Поддержка смешанного ввода
- [ ] Добавить валидацию и предпросмотр распарсенных слов
- [ ] Обновить компонент `WordInput.tsx`

#### 10.2. Определение языка слова
- [ ] Создать функцию определения языка через LLM
- [ ] Промпт для определения языка слова
- [ ] Кэширование результатов определения

#### 10.3. Анализ смешанных языков
- [ ] Создать функцию анализа списка слов через LLM
- [ ] Промпт для анализа (редактируемый пользователем)
- [ ] Определение, какие слова на изучаемом языке, какие на родном
- [ ] Возврат JSON с парами переводов
- [ ] Предзаполнение переводов в форме

#### 10.4. Автоматический перевод
- [ ] Создать функцию перевода через LLM
- [ ] Промпт для перевода (редактируемый пользователем)
- [ ] Автоматический запуск перевода недостающих слов
- [ ] Интеграция с формой создания карточек

#### 10.5. Специфика для немецкого языка
- [ ] Определение части речи через LLM
- [ ] Автоматическое добавление артиклей (der, die, das)
- [ ] Автоматическая капитализация существительных
- [ ] Обновление отображения слов в интерфейсе

#### 10.6. Ввод слов картинкой (OCR)
- [ ] Создать компонент для загрузки изображения
- [ ] Интеграция с OpenAI Vision API (GPT-4 Vision)
- [ ] Распознавание рукописного текста
- [ ] Распознавание текста под разными углами
- [ ] Парсинг распознанного текста

### Критерии завершения этапа
- ✅ Улучшенный парсинг ввода работает корректно
- ✅ Анализ смешанных языков работает
- ✅ Автоматический перевод работает
- ✅ Немецкие слова обрабатываются с артиклями и капитализацией
- ✅ Ввод картинкой работает (опционально)

**Ориентировочное время:** 5-6 дней

---

## Этап 11: Улучшения генерации медиа

**Цель:** Улучшить промпты для генерации изображений и аудио, добавить цветовые схемы и разнообразие голосов.

### Задачи

#### 11.1. Улучшение промптов для изображений
- [ ] Обновить промпты с учетом требований:
  - [ ] Запрет лишних надписей на непонятных языках
  - [ ] Слово на языке изучения на картинке
  - [ ] Английский перевод в желтой подложке
  - [ ] Для абстрактных понятий - символы/метафоры
- [ ] Использование промптов пользователя (если настроены)
- [ ] Обновить функцию `generate_image_with_dalle`

#### 11.2. Определение части речи для цветовой схемы
- [ ] Создать функцию определения части речи через LLM
- [ ] Промпт для определения части речи (для каждого языка)
- [ ] Кэширование результатов

#### 11.3. Цветовая схема по частям речи
- [ ] Определение цветовой схемы:
  - [ ] Глаголы: холодные тона (синий, темно-синий, зеленоватые)
  - [ ] Существительные: электрик цвета
  - [ ] Прилагательные: электрик цвета
  - [ ] Остальные: случайные цвета
- [ ] Передача цветовой схемы в промпт для DALL-E
- [ ] Применение к самой картинке (не к фону)

#### 11.4. Улучшение генерации аудио
- [ ] Добавить разнообразие голосов:
  - [ ] Женский голос
  - [ ] Мужской голос
  - [ ] Детский голос (для всех языков)
- [ ] Случайный выбор голоса для каждого слова
- [ ] Вариация громкости (в пределах 50% от стандартной)
- [ ] Настройки по частям речи:
  - [ ] Глаголы: быстрее и эмоциональнее
  - [ ] Остальные: стандартная скорость

#### 11.5. Интеграция с генерацией карточек
- [ ] Использование улучшенных промптов
- [ ] Применение цветовых схем
- [ ] Использование разнообразных голосов

### Критерии завершения этапа
- ✅ Промпты для изображений улучшены
- ✅ Цветовые схемы применяются к картинкам
- ✅ Разнообразие голосов работает
- ✅ Настройки по частям речи применяются

**Ориентировочное время:** 4-5 дней

---

## Этап 12: Упрощенный режим и автоматизация

**Цель:** Создать упрощенный режим работы с автоматической генерацией всех элементов.

### Задачи

#### 12.1. Переключатель режимов
- [ ] Добавить переключатель "Упрощенный/Сложный режим" в профиле
- [ ] Сохранение выбора в профиле пользователя
- [ ] Отображение текущего режима в интерфейсе

#### 12.2. Упрощенный режим - интерфейс
- [ ] Упрощенный интерфейс ввода слов
- [ ] Автоматический запуск всех LLM процессов
- [ ] Минимум подтверждений от пользователя
- [ ] Индикаторы прогресса

#### 12.3. Автоматическая генерация названия колоды
- [ ] Функция генерации названия через LLM
- [ ] Промпт для генерации названия
- [ ] Учет категорий и частей речи
- [ ] Автоматическое заполнение поля "Название колоды"

#### 12.4. Автоматическое определение категорий
- [ ] Функция определения категорий через LLM
- [ ] Промпт с ~100 категориями
- [ ] Определение категории для каждого слова
- [ ] Использование категорий при генерации названия колоды

#### 12.5. Автоматическая генерация медиа
- [ ] Автоматическая генерация изображений для всех слов
- [ ] Автоматическая генерация аудио для всех слов
- [ ] Параллельная обработка (если возможно)
- [ ] Обработка ошибок и повторные попытки

#### 12.6. Сложный режим (текущий)
- [ ] Сохранить текущий режим как "Сложный"
- [ ] Все действия требуют подтверждения
- [ ] Пользователь контролирует каждый шаг

### Критерии завершения этапа
- ✅ Упрощенный режим работает
- ✅ Автоматическая генерация названия колоды работает
- ✅ Автоматическое определение категорий работает
- ✅ Автоматическая генерация медиа работает
- ✅ Сложный режим сохранен и работает

**Ориентировочное время:** 5-6 дней

---

## Этап 13: Система токенов для контроля генерации

**Цель:** Реализовать систему внутренней валюты (токенов) для контроля генерации карточек.

### Задачи

#### 13.1. Backend - Модели данных
- [ ] Создать модель `Token`:
  - [ ] `user` (OneToOneField к User)
  - [ ] `balance` (IntegerField, default=0)
  - [ ] `total_earned` (IntegerField, default=0)
  - [ ] `total_spent` (IntegerField, default=0)
  - [ ] `created_at`, `updated_at`
- [ ] Создать модель `TokenTransaction`:
  - [ ] `user` (ForeignKey к User)
  - [ ] `amount` (IntegerField)
  - [ ] `transaction_type` (CharField: 'earned', 'spent', 'refund')
  - [ ] `description` (CharField, max_length=255)
  - [ ] `created_by` (ForeignKey к User, null=True, для админа)
  - [ ] `created_at` (DateTimeField)
- [ ] Создать миграции
- [ ] Написать тесты для моделей

#### 13.2. Backend - API для работы с токенами
- [ ] Создать сериализаторы:
  - [ ] `TokenSerializer`
  - [ ] `TokenTransactionSerializer`
  - [ ] `AddTokensSerializer` (для админа)
  - [ ] `SpendTokensSerializer`
  - [ ] `RefundTokensSerializer`
- [ ] Создать API endpoints:
  - [ ] `GET /api/tokens/balance/` - получение баланса
  - [ ] `POST /api/tokens/add/` - начисление токенов (только админ)
  - [ ] `POST /api/tokens/spend/` - списание токенов
  - [ ] `POST /api/tokens/refund/` - возврат токенов
- [ ] Добавить проверку прав доступа (админ для начисления)
- [ ] Написать тесты для API

#### 13.3. Backend - Интеграция списания токенов
- [ ] Обновить `generate_cards_view`:
  - [ ] Проверка баланса перед генерацией
  - [ ] Списание токенов (1 токен за каждое слово)
  - [ ] Обработка ошибок с возвратом токенов
  - [ ] Создание транзакций для каждого слова
- [ ] Добавить логирование транзакций
- [ ] Написать тесты для списания и возврата

#### 13.4. Админ-панель
- [ ] Зарегистрировать `Token` в админке:
  - [ ] Отображение баланса пользователя
  - [ ] Кнопка "Начислить токены"
  - [ ] История транзакций
- [ ] Зарегистрировать `TokenTransaction` в админке:
  - [ ] Фильтры по пользователям, типам транзакций
  - [ ] Поиск по описанию
  - [ ] Отображение создателя транзакции
- [ ] Создать кастомный action для массового начисления токенов

#### 13.5. Frontend - Компонент TokenBalance
- [ ] Создать компонент `TokenBalance.tsx`:
  - [ ] Отображение текущего баланса
  - [ ] Индикатор низкого баланса (< 10 токенов)
  - [ ] Обновление баланса в реальном времени
- [ ] Интегрировать в главную страницу (Header или Sidebar)
- [ ] Добавить стили для отображения баланса

#### 13.6. Frontend - Интеграция в GenerateButton
- [ ] Обновить `GenerateButton.tsx`:
  - [ ] Проверка баланса перед генерацией
  - [ ] Отображение ошибки при недостатке токенов
  - [ ] Обновление баланса после успешной генерации
  - [ ] Обработка возврата токенов при ошибке
- [ ] Добавить предупреждение при низком балансе

#### 13.7. Frontend - API клиент
- [ ] Добавить методы в `api.ts`:
  - [ ] `getTokenBalance()` - получение баланса
  - [ ] `spendTokens(amount, description)` - списание токенов
  - [ ] `refundTokens(amount, description)` - возврат токенов
- [ ] Обработка ошибок API

#### 13.8. Тестирование
- [ ] Unit-тесты для моделей Token
- [ ] Unit-тесты для API endpoints
- [ ] Интеграционные тесты для списания/возврата
- [ ] Тесты для админ-панели
- [ ] Frontend тесты для компонента TokenBalance

### Критерии завершения этапа
- ✅ Модели Token и TokenTransaction созданы и протестированы
- ✅ API для работы с токенами работает
- ✅ Списание токенов интегрировано в генерацию карточек
- ✅ Возврат токенов работает при ошибках
- ✅ Админ может начислять токены через админ-панель
- ✅ Пользователь видит баланс токенов в интерфейсе
- ✅ Баланс обновляется после генерации карточек
- ✅ Все тесты проходят

**Ориентировочное время:** 3-4 дня

---

## Этап 7: Интеграция, тестирование и оптимизация

**Цель:** Протестировать все функции, исправить ошибки и оптимизировать производительность.

### Задачи

#### 6.1. Интеграционное тестирование
- [ ] Протестировать полный цикл:
  - [ ] Регистрация → Вход → Ввод слов → Ввод переводов → Загрузка медиа → Генерация → Скачивание
- [ ] Протестировать различные сценарии:
  - [ ] Генерация без медиа
  - [ ] Генерация только с аудио
  - [ ] Генерация только с изображениями
  - [ ] Генерация с обоими типами медиа
- [ ] Протестировать обработку ошибок:
  - [ ] Неверные данные
  - [ ] Сетевые ошибки
  - [ ] Ошибки сервера

#### 6.2. Тестирование Backend
- [ ] Написать unit-тесты для моделей
- [ ] Написать unit-тесты для сериализаторов
- [ ] Написать unit-тесты для views
- [ ] Написать тесты для генерации `.apkg` файлов
- [ ] Проверить покрытие тестами (минимум 70%)

#### 6.3. Тестирование Frontend
- [ ] Протестировать все компоненты
- [ ] Протестировать интеграцию с API
- [ ] Протестировать обработку ошибок
- [ ] Протестировать валидацию форм

#### 6.4. Проверка безопасности
- [ ] Проверить защиту от SQL-инъекций
- [ ] Проверить валидацию входных данных
- [ ] Проверить защиту от CSRF
- [ ] Проверить правильность работы аутентификации
- [ ] Проверить изоляцию данных пользователей

#### 6.5. Оптимизация производительности
- [ ] Оптимизировать запросы к БД (использовать select_related, prefetch_related)
- [ ] Добавить кэширование для часто используемых данных (опционально)
- [ ] Оптимизировать размер медиафайлов перед сохранением
- [ ] Оптимизировать генерацию `.apkg` файлов
- [ ] Проверить время отклика API

#### 6.6. Обработка ошибок
- [ ] Добавить логирование ошибок на Backend
- [ ] Добавить обработку исключений
- [ ] Улучшить сообщения об ошибках для пользователя
- [ ] Добавить fallback для критических ошибок

#### 6.7. Очистка кода
- [ ] Проверить код на соответствие стандартам (PEP 8 для Python, ESLint для TypeScript)
- [ ] Удалить неиспользуемый код
- [ ] Добавить комментарии к сложным участкам
- [ ] Рефакторинг дублирующегося кода

#### 6.8. Тестирование на разных устройствах
- [ ] Протестировать на разных браузерах (Chrome, Firefox, Safari)
- [ ] Протестировать на мобильных устройствах
- [ ] Проверить адаптивность интерфейса

### Критерии завершения этапа
- ✅ Все функции протестированы и работают
- ✅ Критические ошибки исправлены
- ✅ Производительность приемлема
- ✅ Код чистый и документированный
- ✅ Безопасность проверена

**Ориентировочное время:** 2-3 дня

---

## Этап 8: Деплой и финализация

**Цель:** Развернуть приложение для использования и завершить документацию.

### Задачи

#### 7.1. Подготовка к деплою
- [ ] Настроить переменные окружения для production
- [ ] Отключить DEBUG режим
- [ ] Настроить ALLOWED_HOSTS
- [ ] Настроить статические файлы (collectstatic)
- [ ] Настроить медиафайлы для production

#### 7.2. Настройка сервера
- [ ] Выбрать хостинг (например, DigitalOcean, AWS, или локальный сервер)
- [ ] Установить необходимые зависимости на сервере
- [ ] Настроить PostgreSQL на сервере
- [ ] Настроить веб-сервер (Nginx)
- [ ] Настроить WSGI сервер (Gunicorn)

#### 7.3. Деплой Backend
- [ ] Загрузить код на сервер
- [ ] Настроить виртуальное окружение
- [ ] Применить миграции
- [ ] Создать суперпользователя
- [ ] Настроить Gunicorn
- [ ] Настроить Nginx для проксирования
- [ ] Протестировать доступность API

#### 7.4. Деплой Frontend
- [ ] Собрать production build (`npm run build`)
- [ ] Настроить Nginx для раздачи статических файлов
- [ ] Настроить проксирование API запросов
- [ ] Протестировать работу приложения

#### 7.5. Настройка домена и SSL
- [ ] Настроить доменное имя (опционально)
- [ ] Настроить SSL сертификат (Let's Encrypt)
- [ ] Настроить редиректы с HTTP на HTTPS

#### 7.6. Мониторинг и логирование
- [ ] Настроить логирование на сервере
- [ ] Настроить мониторинг ошибок (опционально)
- [ ] Настроить резервное копирование БД

#### 7.7. Документация
- [ ] Обновить README.md с инструкциями по деплою
- [ ] Создать документацию для пользователей (как использовать приложение)
- [ ] Создать документацию для разработчиков (если нужно)
- [ ] Добавить скриншоты интерфейса

#### 7.8. Финальное тестирование
- [ ] Протестировать все функции на production сервере
- [ ] Протестировать с несколькими пользователями
- [ ] Проверить производительность под нагрузкой
- [ ] Исправить найденные проблемы

#### 7.9. Подготовка для пользователей
- [ ] Создать аккаунты для всех пользователей (или инструкции по регистрации)
- [ ] Подготовить инструкцию по использованию
- [ ] Провести демонстрацию приложения

### Критерии завершения этапа
- ✅ Приложение развернуто и доступно
- ✅ Все функции работают на production
- ✅ Документация завершена
- ✅ Пользователи могут начать использовать приложение

**Ориентировочное время:** 2-3 дня

---

## Общая временная оценка

- **Этап 1:** 1-2 дня
- **Этап 2:** 2-3 дня
- **Этап 3:** 3-4 дня
- **Этап 4:** 3-4 дня
- **Этап 5:** 3-4 дня (Backend - OpenAI интеграция)
- **Этап 6:** 3-4 дня (Frontend - генерация медиа)
- **Этап 7:** 2-3 дня (Тестирование и оптимизация)
- **Этап 8:** 2-3 дня (Деплой)
- **Этап 9:** 4-5 дней (Профиль пользователя и мультиязычность)
- **Этап 10:** 5-6 дней (Улучшение ввода слов и анализ смешанных языков)
- **Этап 11:** 4-5 дней (Улучшения генерации медиа)
- **Этап 12:** 5-6 дней (Упрощенный режим и автоматизация)
- **Этап 13:** 3-4 дня (Система токенов для контроля генерации)

**Итого:** 40-52 дня (примерно 8-10 недель при работе в свободное время)

---

## Приоритеты и зависимости

### Критический путь (необходимо для базовой функциональности):
1. Этап 1 → Этап 2 → Этап 3 → Этап 4 → Этап 5 → Этап 6 → Этап 7 → Этап 8

### Расширенная функциональность:
2. Этап 9 → Этап 10 → Этап 11 → Этап 12 → Этап 13

### Можно делать параллельно:
- Некоторые задачи из Этапа 7 можно выполнять параллельно с разработкой
- Этап 9 и Этап 10 могут частично выполняться параллельно

### Рекомендации:
- Сначала реализовать базовую функциональность (Этапы 1-4)
- Затем интегрировать OpenAI API (Этап 5)
- После этого создать Frontend для генерации медиа (Этап 6)
- Затем тестировать и оптимизировать (Этап 7)
- В конце деплоить (Этап 8)
- После базовой версии добавить расширенную функциональность (Этапы 9-12)

---

## Заметки

- План может корректироваться в процессе разработки
- Некоторые задачи могут быть упрощены или пропущены в зависимости от приоритетов
- Рекомендуется делать коммиты после завершения каждой задачи
- Важно тестировать на каждом этапе, а не только в конце

---

## Промпты для LLM (дополнительные)

### Промпт для определения части речи
```
Определи часть речи для слова "{word}" на языке {language}.
Для немецкого языка также определи артикль.
Верни JSON: {"part_of_speech": "...", "article": "der|die|das" (только для немецкого), "capitalized": "..."}
```

### Промпт для определения категории
```
Определи категорию для слова "{word}" на языке {language}.
Выбери из следующих категорий: [список ~100 категорий].
Верни JSON: {"category": "название_категории"}
```

### Промпт для OCR (распознавание текста с изображения)
```
Распознай текст на этом изображении.
Текст может быть написан от руки, под разными углами.
Верни только список слов, разделенных запятыми.
Игнорируй точки и другие знаки препинания.
```

**Примечание:** Все промпты должны быть переведены на родной язык пользователя перед отправкой в LLM.

