# Детальный поэтапный план разработки Anki Card Generator

## Общая информация

Этот документ описывает детальный план разработки приложения для генерации карточек Anki. План разбит на 7 этапов, каждый из которых содержит конкретные задачи и критерии завершения.

---

## Этап 1: Настройка проекта и инфраструктуры

**Цель:** Создать базовую структуру проекта, настроить окружение разработки и необходимые инструменты.

### Задачи

#### 1.1. Инициализация проекта
- [ ] Создать структуру директорий проекта
- [ ] Инициализировать Git репозиторий
- [ ] Создать `.gitignore` для Python и Node.js
- [ ] Создать базовый `README.md`

#### 1.2. Настройка Backend (Django)
- [ ] Создать виртуальное окружение Python
- [ ] Установить Django 4.x
- [ ] Создать Django проект (`django-admin startproject config`)
- [ ] Настроить структуру приложений (`apps/users`, `apps/words`, `apps/cards`)
- [ ] Создать `requirements.txt` с базовыми зависимостями
- [ ] Настроить `settings.py`:
  - [ ] Подключение к PostgreSQL
  - [ ] Настройка Django REST Framework
  - [ ] Настройка CORS
  - [ ] Настройка MEDIA_ROOT и MEDIA_URL
  - [ ] Загрузка переменных окружения через `python-dotenv`

#### 1.3. Настройка базы данных
- [ ] Установить и настроить PostgreSQL
- [ ] Создать базу данных `anki_db`
- [ ] Настроить подключение в `settings.py`
- [ ] Протестировать подключение

#### 1.4. Настройка Frontend (React)
- [ ] Создать React приложение с TypeScript (`npx create-react-app frontend --template typescript`)
- [ ] Установить и настроить TailwindCSS
- [ ] Установить Axios для HTTP-запросов
- [ ] Настроить структуру папок (`components/`, `services/`, `types/`)
- [ ] Создать базовый `App.tsx`
- [ ] Настроить `package.json` с необходимыми зависимостями

#### 1.5. Настройка переменных окружения
- [ ] Создать `.env.example` с примерами переменных
- [ ] Создать `.env` для разработки
- [ ] Настроить переменные:
  - `DATABASE_URL`
  - `SECRET_KEY`
  - `DEBUG`
  - `ALLOWED_HOSTS`
  - `CORS_ALLOWED_ORIGINS`

### Критерии завершения этапа
- ✅ Проект успешно запускается локально
- ✅ Backend отвечает на запросы (проверка через `/admin`)
- ✅ Frontend запускается и отображает базовую страницу
- ✅ База данных подключена и работает
- ✅ Все зависимости установлены

**Ориентировочное время:** 1-2 дня

---

## Этап 2: Backend - Модели данных и аутентификация

**Цель:** Создать модели базы данных, систему аутентификации и базовые API endpoints.

### Задачи

#### 2.1. Модель User
- [ ] Создать приложение `apps/users`
- [ ] Расширить стандартную модель User Django:
  - [ ] Добавить поле `preferred_language` (CharField, choices: 'pt', 'de')
  - [ ] Добавить поле `created_at` (DateTimeField, auto_now_add)
- [ ] Создать миграции
- [ ] Применить миграции

#### 2.2. Модель Word
- [ ] Создать приложение `apps/words`
- [ ] Создать модель `Word`:
  - [ ] `user` (ForeignKey к User)
  - [ ] `original_word` (CharField, max_length=200)
  - [ ] `translation` (CharField, max_length=200)
  - [ ] `language` (CharField, choices: 'pt', 'de')
  - [ ] `audio_file` (FileField, null=True, blank=True)
  - [ ] `image_file` (ImageField, null=True, blank=True)
  - [ ] `created_at` (DateTimeField, auto_now_add)
  - [ ] `updated_at` (DateTimeField, auto_now)
- [ ] Добавить уникальный индекс `(user, original_word, language)`
- [ ] Создать миграции
- [ ] Применить миграции

#### 2.3. Система аутентификации
- [ ] Установить и настроить `djangorestframework-simplejwt` (или использовать токены DRF)
- [ ] Создать сериализаторы:
  - [ ] `UserRegistrationSerializer`
  - [ ] `UserLoginSerializer`
  - [ ] `UserProfileSerializer`
- [ ] Создать ViewSets/Views:
  - [ ] `RegisterView` (POST `/api/auth/register/`)
  - [ ] `LoginView` (POST `/api/auth/login/`)
  - [ ] `UserProfileView` (GET/PATCH `/api/user/profile/`)
- [ ] Настроить URL-маршруты
- [ ] Добавить проверку аутентификации для защищенных endpoints

#### 2.4. API для работы со словами (базовый)
- [ ] Создать сериализатор `WordSerializer`
- [ ] Создать ViewSet для списка слов:
  - [ ] `GET /api/words/list/` — список всех слов пользователя
  - [ ] Фильтрация по `language` (query param)
  - [ ] Поиск по `original_word` и `translation` (query param `search`)
- [ ] Настроить пагинацию (опционально)
- [ ] Добавить фильтрацию по текущему пользователю

#### 2.5. Тестирование API
- [ ] Протестировать регистрацию через Postman/curl
- [ ] Протестировать вход и получение токена
- [ ] Протестировать получение профиля
- [ ] Протестировать список слов (с аутентификацией)

### Критерии завершения этапа
- ✅ Модели созданы и применены в БД
- ✅ Регистрация и вход работают
- ✅ API возвращает корректные данные
- ✅ Аутентификация защищает endpoints
- ✅ Все запросы протестированы

**Ориентировочное время:** 2-3 дня

---

## Этап 3: Backend - Генерация карточек Anki

**Цель:** Реализовать логику генерации `.apkg` файлов с использованием библиотеки `genanki`.

### Задачи

#### 3.1. Установка и изучение genanki
- [ ] Установить библиотеку `genanki`
- [ ] Изучить документацию и примеры
- [ ] Создать тестовый скрипт для генерации простой колоды

#### 3.2. Создание приложения cards
- [ ] Создать приложение `apps/cards`
- [ ] Создать утилиты для работы с genanki:
  - [ ] Функция создания модели карточек (Model)
  - [ ] Функция создания колоды (Deck)
  - [ ] Функция добавления записей (Notes)

#### 3.3. Логика генерации .apkg
- [ ] Создать функцию `generate_apkg()`:
  - [ ] Принимает список слов, переводы, медиафайлы, название колоды
  - [ ] Создает модель карточек (двусторонние)
  - [ ] Создает колоду с указанным названием
  - [ ] Добавляет записи для каждого слова
  - [ ] Упаковывает медиафайлы
  - [ ] Генерирует `.apkg` файл
  - [ ] Сохраняет файл во временное хранилище
  - [ ] Возвращает путь к файлу и UUID

#### 3.4. API для генерации карточек
- [ ] Создать сериализатор `CardGenerationSerializer`:
  - [ ] `words` (строка через запятую)
  - [ ] `language` (pt/de)
  - [ ] `translations` (JSON объект)
  - [ ] `audio_files` (JSON объект, опционально)
  - [ ] `image_files` (JSON объект, опционально)
  - [ ] `deck_name` (строка)
- [ ] Создать View `GenerateCardsView`:
  - [ ] Валидация входных данных
  - [ ] Парсинг списка слов
  - [ ] Проверка на дубликаты в БД
  - [ ] Сохранение новых слов в БД
  - [ ] Вызов функции генерации `.apkg`
  - [ ] Возврат ссылки на скачивание
- [ ] Создать View `DownloadCardsView`:
  - [ ] Получение файла по UUID
  - [ ] Отправка файла пользователю
  - [ ] Очистка старых файлов (опционально)

#### 3.5. Обработка медиафайлов
- [ ] Настроить загрузку файлов через Django
- [ ] Создать функции для валидации:
  - [ ] Аудио: только MP3, проверка размера
  - [ ] Изображения: только JPG/PNG, проверка размера
- [ ] Создать функции для сохранения:
  - [ ] Генерация уникальных имен файлов (UUID)
  - [ ] Сохранение в `MEDIA_ROOT`
  - [ ] Возврат путей для использования в genanki

#### 3.6. Сохранение слов в БД
- [ ] При генерации карточек сохранять все слова в модель `Word`
- [ ] Проверка на дубликаты перед сохранением
- [ ] Если слово уже существует — использовать существующую запись
- [ ] Обновление `updated_at` при повторном использовании

#### 3.7. Тестирование генерации
- [ ] Протестировать генерацию простой колоды (без медиа)
- [ ] Протестировать генерацию с аудио
- [ ] Протестировать генерацию с изображениями
- [ ] Протестировать генерацию с обоими типами медиа
- [ ] Проверить импорт `.apkg` в Anki Desktop
- [ ] Проверить корректность двусторонних карточек

### Критерии завершения этапа
- ✅ `.apkg` файлы генерируются корректно
- ✅ Файлы успешно импортируются в Anki
- ✅ Двусторонние карточки работают правильно
- ✅ Медиафайлы включаются в колоду
- ✅ Слова сохраняются в БД
- ✅ API endpoints работают и протестированы

**Ориентировочное время:** 3-4 дня

---

## Этап 4: Frontend - Базовый интерфейс

**Цель:** Создать базовый пользовательский интерфейс для ввода данных и генерации карточек.

### Задачи

#### 4.1. Настройка API клиента
- [ ] Создать файл `src/services/api.ts`
- [ ] Настроить базовый URL для Axios
- [ ] Настроить interceptors для добавления токена аутентификации
- [ ] Создать функции для API запросов:
  - [ ] `register()`
  - [ ] `login()`
  - [ ] `getProfile()`
  - [ ] `updateProfile()`
  - [ ] `getWordsList()`
  - [ ] `generateCards()`
  - [ ] `downloadCards()`

#### 4.2. Типы TypeScript
- [ ] Создать файл `src/types/index.ts`
- [ ] Определить типы:
  - [ ] `User`
  - [ ] `Word`
  - [ ] `CardGenerationRequest`
  - [ ] `CardGenerationResponse`
  - [ ] `Language` ('pt' | 'de')

#### 4.3. Компонент аутентификации
- [ ] Создать компонент `LoginForm.tsx`:
  - [ ] Поля: username, password
  - [ ] Валидация формы
  - [ ] Обработка ошибок
  - [ ] Сохранение токена в localStorage
- [ ] Создать компонент `RegisterForm.tsx`:
  - [ ] Поля: username, email, password, preferred_language
  - [ ] Валидация формы
  - [ ] Обработка ошибок
- [ ] Создать контекст `AuthContext` для управления состоянием аутентификации

#### 4.4. Компонент WordInput
- [ ] Создать компонент `WordInput.tsx`:
  - [ ] Текстовое поле для ввода слов через запятую
  - [ ] Валидация ввода (не пустое, минимум одно слово)
  - [ ] Отображение списка введенных слов
  - [ ] Возможность удаления слов из списка
  - [ ] Подсветка валидных/невалидных слов

#### 4.5. Компонент LanguageSelector
- [ ] Создать компонент `LanguageSelector.tsx`:
  - [ ] Выпадающий список (select) с опциями 'pt' и 'de'
  - [ ] Загрузка `preferred_language` из профиля пользователя
  - [ ] Сохранение выбора в профиле при изменении
  - [ ] Отображение названий языков на русском

#### 4.6. Компонент для ввода переводов
- [ ] Создать компонент `TranslationInput.tsx`:
  - [ ] Динамический список полей для каждого слова
  - [ ] Поле ввода перевода для каждого слова
  - [ ] Валидация (обязательное поле)
  - [ ] Отображение исходного слова рядом с полем перевода

#### 4.7. Компонент GenerateButton
- [ ] Создать компонент `GenerateButton.tsx`:
  - [ ] Кнопка "Сгенерировать карточки"
  - [ ] Индикатор загрузки (disabled во время генерации)
  - [ ] Обработка успешного ответа
  - [ ] Автоматическое скачивание файла
  - [ ] Обработка ошибок с отображением сообщений

#### 4.8. Главный компонент App
- [ ] Создать структуру `App.tsx`:
  - [ ] Проверка аутентификации
  - [ ] Роутинг (Login/Register/Main)
  - [ ] Интеграция всех компонентов
  - [ ] Обработка состояния загрузки
  - [ ] Обработка ошибок

#### 4.9. Базовые стили
- [ ] Настроить TailwindCSS
- [ ] Создать базовые стили для форм
- [ ] Создать стили для кнопок
- [ ] Создать стили для индикаторов загрузки
- [ ] Адаптивный дизайн (базовый)

### Критерии завершения этапа
- ✅ Пользователь может зарегистрироваться и войти
- ✅ Пользователь может ввести слова и выбрать язык
- ✅ Пользователь может ввести переводы
- ✅ Пользователь может сгенерировать карточки
- ✅ Файл автоматически скачивается
- ✅ Базовые стили применены

**Ориентировочное время:** 3-4 дня

---

## Этап 5: Backend - Интеграция OpenAI API для генерации медиа

**Цель:** Реализовать автоматическую генерацию изображений и аудио через OpenAI API.

### Задачи

#### 5.1. Установка и настройка OpenAI SDK
- [ ] Установить библиотеку `openai` (версия 1.12.0+)
- [ ] Добавить `OPENAI_API_KEY` в переменные окружения
- [ ] Создать утилиту для инициализации OpenAI клиента
- [ ] Настроить обработку ошибок API

#### 5.2. Генерация изображений через DALL-E 3
- [ ] Создать функцию `generate_image_with_dalle()`:
  - [ ] Принимает слово, перевод, язык
  - [ ] Формирует промпт для генерации изображения (например: "A simple, clear illustration of [word] ([translation] in Russian)")
  - [ ] Вызывает OpenAI DALL-E 3 API (`dall-e-3` модель)
  - [ ] Сохраняет изображение локально с уникальным именем (UUID)
  - [ ] Возвращает путь к сохраненному файлу
- [ ] Обработка ошибок API (rate limits, invalid requests)
- [ ] Валидация размера и формата полученного изображения

#### 5.3. Генерация аудио через TTS-1-HD
- [ ] Создать функцию `generate_audio_with_tts()`:
  - [ ] Принимает слово и язык
  - [ ] Определяет голос в зависимости от языка (pt → португальский голос, de → немецкий голос)
  - [ ] Вызывает OpenAI TTS API (`tts-1-hd` модель)
  - [ ] Сохраняет аудио в формате MP3 с уникальным именем (UUID)
  - [ ] Возвращает путь к сохраненному файлу
- [ ] Обработка ошибок API
- [ ] Валидация формата и качества аудио

#### 5.4. API endpoints для генерации медиа
- [ ] Создать приложение `apps/media` (или добавить в `apps/cards`)
- [ ] Создать сериализаторы:
  - [ ] `ImageGenerationSerializer` (word, translation, language)
  - [ ] `AudioGenerationSerializer` (word, language)
- [ ] Создать Views:
  - [ ] `GenerateImageView` (POST `/api/media/generate-image/`)
  - [ ] `GenerateAudioView` (POST `/api/media/generate-audio/`)
- [ ] Добавить аутентификацию для endpoints
- [ ] Настроить URL-маршруты

#### 5.5. API endpoints для загрузки собственных медиа
- [ ] Создать сериализаторы:
  - [ ] `ImageUploadSerializer` (file field)
  - [ ] `AudioUploadSerializer` (file field)
- [ ] Создать Views:
  - [ ] `UploadImageView` (POST `/api/media/upload-image/`)
  - [ ] `UploadAudioView` (POST `/api/media/upload-audio/`)
- [ ] Валидация форматов файлов:
  - [ ] Изображения: только JPG, PNG (максимум 10MB)
  - [ ] Аудио: только MP3 (максимум 5MB)
- [ ] Сохранение файлов с уникальными именами
- [ ] Возврат URL к загруженному файлу

#### 5.6. Обновление модели Word
- [ ] Добавить поля для хранения ID сгенерированных медиа (опционально):
  - [ ] `generated_image_id` (CharField, null=True)
  - [ ] `generated_audio_id` (CharField, null=True)
- [ ] Или использовать существующие поля `image_file` и `audio_file`

#### 5.7. Тестирование генерации медиа
- [ ] Протестировать генерацию изображений для разных слов
- [ ] Протестировать генерацию аудио для разных языков
- [ ] Протестировать обработку ошибок API
- [ ] Протестировать загрузку собственных файлов
- [ ] Проверить качество сгенерированных медиафайлов

### Критерии завершения этапа
- ✅ OpenAI API интегрирован и работает
- ✅ Изображения генерируются через DALL-E 3
- ✅ Аудио генерируется через TTS-1-HD
- ✅ Пользователь может загружать собственные медиафайлы
- ✅ Все API endpoints протестированы
- ✅ Обработка ошибок реализована

**Ориентировочное время:** 3-4 дня

---

## Этап 6: Frontend - Генерация и управление медиафайлами

**Цель:** Создать пользовательский интерфейс для генерации и управления медиафайлами через OpenAI API.

### Задачи

#### 6.1. Компонент MediaGenerator
- [x] Создать компонент `MediaGenerator.tsx`:
  - [x] Принимает слово, перевод, язык как props
  - [x] Отображает кнопки "Добавить картинку" и "Добавить аудио"
  - [x] Интеграция с API для генерации медиа
  - [x] Индикатор загрузки при генерации
  - [x] Предпросмотр сгенерированных/загруженных медиафайлов
  - [x] Кнопка "Перегенерировать" для каждого медиафайла
  - [x] Кнопка "Загрузить свой вариант" для каждого медиафайла

#### 6.2. Компонент для загрузки собственных файлов
- [x] Создать компонент `FileUpload.tsx`:
  - [x] Поле для загрузки файла (input type="file")
  - [x] Валидация формата и размера на клиенте
  - [x] Предпросмотр загруженного файла
  - [x] Отображение имени файла
  - [x] Возможность удалить загруженный файл
  - [x] Интеграция с API для загрузки

#### 6.3. Интеграция MediaGenerator в форму
- [x] Добавить `MediaGenerator` для каждого слова в списке
- [x] Сохранять состояние медиафайлов (сгенерированных/загруженных) в состоянии формы
- [x] Передавать медиафайлы в API при генерации карточек
- [x] Отображать статус медиафайлов (нет, генерируется, готово)

#### 6.4. Обновление API клиента
- [x] Добавить функции в `src/services/api.ts`:
  - [x] `generateImage(word, translation, language)`
  - [x] `generateAudio(word, language)`
  - [x] `uploadImage(file)`
  - [x] `uploadAudio(file)`
- [x] Обработка ошибок API
- [x] Обработка успешных ответов

#### 6.5. Улучшение UX
- [x] Добавить toast-уведомления для успешной генерации/загрузки
- [x] Показывать прогресс генерации (индикатор загрузки)
- [x] Блокировать кнопки во время генерации
- [x] Добавить анимации для предпросмотра медиа
- [x] Улучшить визуальное отображение медиафайлов

#### 6.6. Улучшение отображения ошибок
- [x] Отображать ошибки генерации медиа
- [x] Отображать ошибки загрузки файлов
- [x] Предлагать варианты решения (повторить попытку, загрузить свой файл)

#### 6.7. Исправление передачи медиафайлов
- [x] Исправлена передача медиафайлов из frontend в backend
- [x] Исправлена логика сохранения медиафайлов в состоянии
- [x] Медиафайлы корректно добавляются в .apkg файлы

### Критерии завершения этапа
- ✅ Пользователь может генерировать изображения через OpenAI
- ✅ Пользователь может генерировать аудио через OpenAI
- ✅ Пользователь может перегенерировать медиафайлы
- ✅ Пользователь может загружать собственные медиафайлы
- ✅ Предпросмотр медиафайлов работает корректно
- ✅ Интерфейс удобен и интуитивен
- ✅ Медиафайлы корректно передаются из frontend в backend
- ✅ Медиафайлы корректно добавляются в .apkg файлы

**Статус:** ✅ Завершен (13 ноября 2024)

---

## Этап 7: Интеграция, тестирование и оптимизация

**Цель:** Протестировать все функции, исправить ошибки и оптимизировать производительность.

### Задачи

#### 6.1. Интеграционное тестирование
- [ ] Протестировать полный цикл:
  - [ ] Регистрация → Вход → Ввод слов → Ввод переводов → Загрузка медиа → Генерация → Скачивание
- [ ] Протестировать различные сценарии:
  - [ ] Генерация без медиа
  - [ ] Генерация только с аудио
  - [ ] Генерация только с изображениями
  - [ ] Генерация с обоими типами медиа
- [ ] Протестировать обработку ошибок:
  - [ ] Неверные данные
  - [ ] Сетевые ошибки
  - [ ] Ошибки сервера

#### 6.2. Тестирование Backend
- [ ] Написать unit-тесты для моделей
- [ ] Написать unit-тесты для сериализаторов
- [ ] Написать unit-тесты для views
- [ ] Написать тесты для генерации `.apkg` файлов
- [ ] Проверить покрытие тестами (минимум 70%)

#### 6.3. Тестирование Frontend
- [ ] Протестировать все компоненты
- [ ] Протестировать интеграцию с API
- [ ] Протестировать обработку ошибок
- [ ] Протестировать валидацию форм

#### 6.4. Проверка безопасности
- [ ] Проверить защиту от SQL-инъекций
- [ ] Проверить валидацию входных данных
- [ ] Проверить защиту от CSRF
- [ ] Проверить правильность работы аутентификации
- [ ] Проверить изоляцию данных пользователей

#### 6.5. Оптимизация производительности
- [ ] Оптимизировать запросы к БД (использовать select_related, prefetch_related)
- [ ] Добавить кэширование для часто используемых данных (опционально)
- [ ] Оптимизировать размер медиафайлов перед сохранением
- [ ] Оптимизировать генерацию `.apkg` файлов
- [ ] Проверить время отклика API

#### 6.6. Обработка ошибок
- [ ] Добавить логирование ошибок на Backend
- [ ] Добавить обработку исключений
- [ ] Улучшить сообщения об ошибках для пользователя
- [ ] Добавить fallback для критических ошибок

#### 6.7. Очистка кода
- [ ] Проверить код на соответствие стандартам (PEP 8 для Python, ESLint для TypeScript)
- [ ] Удалить неиспользуемый код
- [ ] Добавить комментарии к сложным участкам
- [ ] Рефакторинг дублирующегося кода

#### 6.8. Тестирование на разных устройствах
- [ ] Протестировать на разных браузерах (Chrome, Firefox, Safari)
- [ ] Протестировать на мобильных устройствах
- [ ] Проверить адаптивность интерфейса

### Критерии завершения этапа
- ✅ Все функции протестированы и работают
- ✅ Критические ошибки исправлены
- ✅ Производительность приемлема
- ✅ Код чистый и документированный
- ✅ Безопасность проверена

**Ориентировочное время:** 2-3 дня

---

## Этап 8: Деплой и финализация

**Цель:** Развернуть приложение для использования и завершить документацию.

### Задачи

#### 7.1. Подготовка к деплою
- [ ] Настроить переменные окружения для production
- [ ] Отключить DEBUG режим
- [ ] Настроить ALLOWED_HOSTS
- [ ] Настроить статические файлы (collectstatic)
- [ ] Настроить медиафайлы для production

#### 7.2. Настройка сервера
- [ ] Выбрать хостинг (например, DigitalOcean, AWS, или локальный сервер)
- [ ] Установить необходимые зависимости на сервере
- [ ] Настроить PostgreSQL на сервере
- [ ] Настроить веб-сервер (Nginx)
- [ ] Настроить WSGI сервер (Gunicorn)

#### 7.3. Деплой Backend
- [ ] Загрузить код на сервер
- [ ] Настроить виртуальное окружение
- [ ] Применить миграции
- [ ] Создать суперпользователя
- [ ] Настроить Gunicorn
- [ ] Настроить Nginx для проксирования
- [ ] Протестировать доступность API

#### 7.4. Деплой Frontend
- [ ] Собрать production build (`npm run build`)
- [ ] Настроить Nginx для раздачи статических файлов
- [ ] Настроить проксирование API запросов
- [ ] Протестировать работу приложения

#### 7.5. Настройка домена и SSL
- [ ] Настроить доменное имя (опционально)
- [ ] Настроить SSL сертификат (Let's Encrypt)
- [ ] Настроить редиректы с HTTP на HTTPS

#### 7.6. Мониторинг и логирование
- [ ] Настроить логирование на сервере
- [ ] Настроить мониторинг ошибок (опционально)
- [ ] Настроить резервное копирование БД

#### 7.7. Документация
- [ ] Обновить README.md с инструкциями по деплою
- [ ] Создать документацию для пользователей (как использовать приложение)
- [ ] Создать документацию для разработчиков (если нужно)
- [ ] Добавить скриншоты интерфейса

#### 7.8. Финальное тестирование
- [ ] Протестировать все функции на production сервере
- [ ] Протестировать с несколькими пользователями
- [ ] Проверить производительность под нагрузкой
- [ ] Исправить найденные проблемы

#### 7.9. Подготовка для пользователей
- [ ] Создать аккаунты для всех пользователей (или инструкции по регистрации)
- [ ] Подготовить инструкцию по использованию
- [ ] Провести демонстрацию приложения

### Критерии завершения этапа
- ✅ Приложение развернуто и доступно
- ✅ Все функции работают на production
- ✅ Документация завершена
- ✅ Пользователи могут начать использовать приложение

**Ориентировочное время:** 2-3 дня

---

## Общая временная оценка

- **Этап 1:** 1-2 дня
- **Этап 2:** 2-3 дня
- **Этап 3:** 3-4 дня
- **Этап 4:** 3-4 дня
- **Этап 5:** 3-4 дня (Backend - OpenAI интеграция)
- **Этап 6:** 3-4 дня (Frontend - генерация медиа)
- **Этап 7:** 2-3 дня (Тестирование и оптимизация)
- **Этап 8:** 2-3 дня (Деплой)

**Итого:** 19-27 дней (примерно 4-5 недель при работе в свободное время)

---

## Приоритеты и зависимости

### Критический путь (необходимо для базовой функциональности):
1. Этап 1 → Этап 2 → Этап 3 → Этап 4 → Этап 5 → Этап 6

### Можно делать параллельно:
- Некоторые задачи из Этапа 7 можно выполнять параллельно с разработкой

### Рекомендации:
- Сначала реализовать базовую функциональность (Этапы 1-4)
- Затем интегрировать OpenAI API (Этап 5)
- После этого создать Frontend для генерации медиа (Этап 6)
- Затем тестировать и оптимизировать (Этап 7)
- В конце деплоить (Этап 8)

---

## Заметки

- План может корректироваться в процессе разработки
- Некоторые задачи могут быть упрощены или пропущены в зависимости от приоритетов
- Рекомендуется делать коммиты после завершения каждой задачи
- Важно тестировать на каждом этапе, а не только в конце

