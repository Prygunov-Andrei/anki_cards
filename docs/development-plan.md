# Детальный поэтапный план разработки Anki Card Generator

## Общая информация

Этот документ описывает детальный план разработки приложения для генерации карточек Anki. План разбит на 7 этапов, каждый из которых содержит конкретные задачи и критерии завершения.

---

## Этап 1: Настройка проекта и инфраструктуры

**Цель:** Создать базовую структуру проекта, настроить окружение разработки и необходимые инструменты.

### Задачи

#### 1.1. Инициализация проекта
- [ ] Создать структуру директорий проекта
- [ ] Инициализировать Git репозиторий
- [ ] Создать `.gitignore` для Python и Node.js
- [ ] Создать базовый `README.md`

#### 1.2. Настройка Backend (Django)
- [ ] Создать виртуальное окружение Python
- [ ] Установить Django 4.x
- [ ] Создать Django проект (`django-admin startproject config`)
- [ ] Настроить структуру приложений (`apps/users`, `apps/words`, `apps/cards`)
- [ ] Создать `requirements.txt` с базовыми зависимостями
- [ ] Настроить `settings.py`:
  - [ ] Подключение к PostgreSQL
  - [ ] Настройка Django REST Framework
  - [ ] Настройка CORS
  - [ ] Настройка MEDIA_ROOT и MEDIA_URL
  - [ ] Загрузка переменных окружения через `python-dotenv`

#### 1.3. Настройка базы данных
- [ ] Установить и настроить PostgreSQL
- [ ] Создать базу данных `anki_db`
- [ ] Настроить подключение в `settings.py`
- [ ] Протестировать подключение

#### 1.4. Настройка Frontend (React)
- [ ] Создать React приложение с TypeScript (`npx create-react-app frontend --template typescript`)
- [ ] Установить и настроить TailwindCSS
- [ ] Установить Axios для HTTP-запросов
- [ ] Настроить структуру папок (`components/`, `services/`, `types/`)
- [ ] Создать базовый `App.tsx`
- [ ] Настроить `package.json` с необходимыми зависимостями

#### 1.5. Настройка переменных окружения
- [ ] Создать `.env.example` с примерами переменных
- [ ] Создать `.env` для разработки
- [ ] Настроить переменные:
  - `DATABASE_URL`
  - `SECRET_KEY`
  - `DEBUG`
  - `ALLOWED_HOSTS`
  - `CORS_ALLOWED_ORIGINS`

### Критерии завершения этапа
- ✅ Проект успешно запускается локально
- ✅ Backend отвечает на запросы (проверка через `/admin`)
- ✅ Frontend запускается и отображает базовую страницу
- ✅ База данных подключена и работает
- ✅ Все зависимости установлены

**Ориентировочное время:** 1-2 дня

---

## Этап 2: Backend - Модели данных и аутентификация

**Цель:** Создать модели базы данных, систему аутентификации и базовые API endpoints.

### Задачи

#### 2.1. Модель User
- [ ] Создать приложение `apps/users`
- [ ] Расширить стандартную модель User Django:
  - [ ] Добавить поле `preferred_language` (CharField, choices: 'pt', 'de')
  - [ ] Добавить поле `created_at` (DateTimeField, auto_now_add)
- [ ] Создать миграции
- [ ] Применить миграции

#### 2.2. Модель Word
- [ ] Создать приложение `apps/words`
- [ ] Создать модель `Word`:
  - [ ] `user` (ForeignKey к User)
  - [ ] `original_word` (CharField, max_length=200)
  - [ ] `translation` (CharField, max_length=200)
  - [ ] `language` (CharField, choices: 'pt', 'de')
  - [ ] `audio_file` (FileField, null=True, blank=True)
  - [ ] `image_file` (ImageField, null=True, blank=True)
  - [ ] `created_at` (DateTimeField, auto_now_add)
  - [ ] `updated_at` (DateTimeField, auto_now)
- [ ] Добавить уникальный индекс `(user, original_word, language)`
- [ ] Создать миграции
- [ ] Применить миграции

#### 2.3. Система аутентификации
- [ ] Установить и настроить `djangorestframework-simplejwt` (или использовать токены DRF)
- [ ] Создать сериализаторы:
  - [ ] `UserRegistrationSerializer`
  - [ ] `UserLoginSerializer`
  - [ ] `UserProfileSerializer`
- [ ] Создать ViewSets/Views:
  - [ ] `RegisterView` (POST `/api/auth/register/`)
  - [ ] `LoginView` (POST `/api/auth/login/`)
  - [ ] `UserProfileView` (GET/PATCH `/api/user/profile/`)
- [ ] Настроить URL-маршруты
- [ ] Добавить проверку аутентификации для защищенных endpoints

#### 2.4. API для работы со словами (базовый)
- [ ] Создать сериализатор `WordSerializer`
- [ ] Создать ViewSet для списка слов:
  - [ ] `GET /api/words/list/` — список всех слов пользователя
  - [ ] Фильтрация по `language` (query param)
  - [ ] Поиск по `original_word` и `translation` (query param `search`)
- [ ] Настроить пагинацию (опционально)
- [ ] Добавить фильтрацию по текущему пользователю

#### 2.5. Тестирование API
- [ ] Протестировать регистрацию через Postman/curl
- [ ] Протестировать вход и получение токена
- [ ] Протестировать получение профиля
- [ ] Протестировать список слов (с аутентификацией)

### Критерии завершения этапа
- ✅ Модели созданы и применены в БД
- ✅ Регистрация и вход работают
- ✅ API возвращает корректные данные
- ✅ Аутентификация защищает endpoints
- ✅ Все запросы протестированы

**Ориентировочное время:** 2-3 дня

---

## Этап 3: Backend - Генерация карточек Anki

**Цель:** Реализовать логику генерации `.apkg` файлов с использованием библиотеки `genanki`.

### Задачи

#### 3.1. Установка и изучение genanki
- [ ] Установить библиотеку `genanki`
- [ ] Изучить документацию и примеры
- [ ] Создать тестовый скрипт для генерации простой колоды

#### 3.2. Создание приложения cards
- [ ] Создать приложение `apps/cards`
- [ ] Создать утилиты для работы с genanki:
  - [ ] Функция создания модели карточек (Model)
  - [ ] Функция создания колоды (Deck)
  - [ ] Функция добавления записей (Notes)

#### 3.3. Логика генерации .apkg
- [ ] Создать функцию `generate_apkg()`:
  - [ ] Принимает список слов, переводы, медиафайлы, название колоды
  - [ ] Создает модель карточек (двусторонние)
  - [ ] Создает колоду с указанным названием
  - [ ] Добавляет записи для каждого слова
  - [ ] Упаковывает медиафайлы
  - [ ] Генерирует `.apkg` файл
  - [ ] Сохраняет файл во временное хранилище
  - [ ] Возвращает путь к файлу и UUID

#### 3.4. API для генерации карточек
- [ ] Создать сериализатор `CardGenerationSerializer`:
  - [ ] `words` (строка через запятую)
  - [ ] `language` (pt/de)
  - [ ] `translations` (JSON объект)
  - [ ] `audio_files` (JSON объект, опционально)
  - [ ] `image_files` (JSON объект, опционально)
  - [ ] `deck_name` (строка)
- [ ] Создать View `GenerateCardsView`:
  - [ ] Валидация входных данных
  - [ ] Парсинг списка слов
  - [ ] Проверка на дубликаты в БД
  - [ ] Сохранение новых слов в БД
  - [ ] Вызов функции генерации `.apkg`
  - [ ] Возврат ссылки на скачивание
- [ ] Создать View `DownloadCardsView`:
  - [ ] Получение файла по UUID
  - [ ] Отправка файла пользователю
  - [ ] Очистка старых файлов (опционально)

#### 3.5. Обработка медиафайлов
- [ ] Настроить загрузку файлов через Django
- [ ] Создать функции для валидации:
  - [ ] Аудио: только MP3, проверка размера
  - [ ] Изображения: только JPG/PNG, проверка размера
- [ ] Создать функции для сохранения:
  - [ ] Генерация уникальных имен файлов (UUID)
  - [ ] Сохранение в `MEDIA_ROOT`
  - [ ] Возврат путей для использования в genanki

#### 3.6. Сохранение слов в БД
- [ ] При генерации карточек сохранять все слова в модель `Word`
- [ ] Проверка на дубликаты перед сохранением
- [ ] Если слово уже существует — использовать существующую запись
- [ ] Обновление `updated_at` при повторном использовании

#### 3.7. Тестирование генерации
- [ ] Протестировать генерацию простой колоды (без медиа)
- [ ] Протестировать генерацию с аудио
- [ ] Протестировать генерацию с изображениями
- [ ] Протестировать генерацию с обоими типами медиа
- [ ] Проверить импорт `.apkg` в Anki Desktop
- [ ] Проверить корректность двусторонних карточек

### Критерии завершения этапа
- ✅ `.apkg` файлы генерируются корректно
- ✅ Файлы успешно импортируются в Anki
- ✅ Двусторонние карточки работают правильно
- ✅ Медиафайлы включаются в колоду
- ✅ Слова сохраняются в БД
- ✅ API endpoints работают и протестированы

**Ориентировочное время:** 3-4 дня

---

## Этап 4: Frontend - Базовый интерфейс

**Цель:** Создать базовый пользовательский интерфейс для ввода данных и генерации карточек.

### Задачи

#### 4.1. Настройка API клиента
- [ ] Создать файл `src/services/api.ts`
- [ ] Настроить базовый URL для Axios
- [ ] Настроить interceptors для добавления токена аутентификации
- [ ] Создать функции для API запросов:
  - [ ] `register()`
  - [ ] `login()`
  - [ ] `getProfile()`
  - [ ] `updateProfile()`
  - [ ] `getWordsList()`
  - [ ] `generateCards()`
  - [ ] `downloadCards()`

#### 4.2. Типы TypeScript
- [ ] Создать файл `src/types/index.ts`
- [ ] Определить типы:
  - [ ] `User`
  - [ ] `Word`
  - [ ] `CardGenerationRequest`
  - [ ] `CardGenerationResponse`
  - [ ] `Language` ('pt' | 'de')

#### 4.3. Компонент аутентификации
- [ ] Создать компонент `LoginForm.tsx`:
  - [ ] Поля: username, password
  - [ ] Валидация формы
  - [ ] Обработка ошибок
  - [ ] Сохранение токена в localStorage
- [ ] Создать компонент `RegisterForm.tsx`:
  - [ ] Поля: username, email, password, preferred_language
  - [ ] Валидация формы
  - [ ] Обработка ошибок
- [ ] Создать контекст `AuthContext` для управления состоянием аутентификации

#### 4.4. Компонент WordInput
- [ ] Создать компонент `WordInput.tsx`:
  - [ ] Текстовое поле для ввода слов через запятую
  - [ ] Валидация ввода (не пустое, минимум одно слово)
  - [ ] Отображение списка введенных слов
  - [ ] Возможность удаления слов из списка
  - [ ] Подсветка валидных/невалидных слов

#### 4.5. Компонент LanguageSelector
- [ ] Создать компонент `LanguageSelector.tsx`:
  - [ ] Выпадающий список (select) с опциями 'pt' и 'de'
  - [ ] Загрузка `preferred_language` из профиля пользователя
  - [ ] Сохранение выбора в профиле при изменении
  - [ ] Отображение названий языков на русском

#### 4.6. Компонент для ввода переводов
- [ ] Создать компонент `TranslationInput.tsx`:
  - [ ] Динамический список полей для каждого слова
  - [ ] Поле ввода перевода для каждого слова
  - [ ] Валидация (обязательное поле)
  - [ ] Отображение исходного слова рядом с полем перевода

#### 4.7. Компонент GenerateButton
- [ ] Создать компонент `GenerateButton.tsx`:
  - [ ] Кнопка "Сгенерировать карточки"
  - [ ] Индикатор загрузки (disabled во время генерации)
  - [ ] Обработка успешного ответа
  - [ ] Автоматическое скачивание файла
  - [ ] Обработка ошибок с отображением сообщений

#### 4.8. Главный компонент App
- [ ] Создать структуру `App.tsx`:
  - [ ] Проверка аутентификации
  - [ ] Роутинг (Login/Register/Main)
  - [ ] Интеграция всех компонентов
  - [ ] Обработка состояния загрузки
  - [ ] Обработка ошибок

#### 4.9. Базовые стили
- [ ] Настроить TailwindCSS
- [ ] Создать базовые стили для форм
- [ ] Создать стили для кнопок
- [ ] Создать стили для индикаторов загрузки
- [ ] Адаптивный дизайн (базовый)

### Критерии завершения этапа
- ✅ Пользователь может зарегистрироваться и войти
- ✅ Пользователь может ввести слова и выбрать язык
- ✅ Пользователь может ввести переводы
- ✅ Пользователь может сгенерировать карточки
- ✅ Файл автоматически скачивается
- ✅ Базовые стили применены

**Ориентировочное время:** 3-4 дня

---

## Этап 5: Frontend - Загрузка медиафайлов и улучшения UX

**Цель:** Добавить возможность загрузки медиафайлов и улучшить пользовательский опыт.

### Задачи

#### 5.1. Компонент загрузки аудио
- [ ] Создать компонент `AudioUpload.tsx`:
  - [ ] Поле для загрузки файла (input type="file", accept="audio/mp3")
  - [ ] Валидация формата (только MP3)
  - [ ] Валидация размера файла (максимум, например, 5MB)
  - [ ] Предпросмотр загруженного файла
  - [ ] Возможность прослушать аудио перед загрузкой
  - [ ] Отображение имени файла
  - [ ] Возможность удалить загруженный файл

#### 5.2. Компонент загрузки изображений
- [ ] Создать компонент `ImageUpload.tsx`:
  - [ ] Поле для загрузки файла (input type="file", accept="image/jpeg,image/png")
  - [ ] Валидация формата (только JPG, PNG)
  - [ ] Валидация размера файла
  - [ ] Предпросмотр изображения
  - [ ] Отображение имени файла
  - [ ] Возможность удалить загруженное изображение

#### 5.3. Интеграция загрузки медиа в форму
- [ ] Добавить компоненты загрузки в главную форму
- [ ] Связать загрузку медиа с конкретными словами
- [ ] Сохранять файлы в состоянии компонента
- [ ] Передавать файлы в API при генерации

#### 5.4. API для загрузки медиафайлов
- [ ] Создать endpoint `POST /api/media/upload/`:
  - [ ] Принимает файл
  - [ ] Валидирует формат и размер
  - [ ] Сохраняет файл с уникальным именем
  - [ ] Возвращает путь к файлу
- [ ] Или интегрировать загрузку в существующий endpoint генерации

#### 5.5. Улучшение UX формы
- [ ] Добавить прогресс-бар или пошаговую форму:
  - [ ] Шаг 1: Ввод слов и выбор языка
  - [ ] Шаг 2: Ввод переводов
  - [ ] Шаг 3: Загрузка медиа (опционально)
  - [ ] Шаг 4: Генерация
- [ ] Добавить валидацию на каждом шаге
- [ ] Добавить кнопки "Назад" и "Далее"
- [ ] Сохранение состояния формы при навигации

#### 5.6. Улучшение отображения ошибок
- [ ] Создать компонент `ErrorMessage.tsx`
- [ ] Отображать ошибки валидации под полями
- [ ] Отображать общие ошибки API
- [ ] Добавить toast-уведомления для успешных операций

#### 5.7. Улучшение индикаторов загрузки
- [ ] Добавить спиннеры для всех асинхронных операций
- [ ] Показывать прогресс генерации (если возможно)
- [ ] Блокировать форму во время загрузки

#### 5.8. Компонент списка слов
- [ ] Создать компонент `WordsList.tsx`:
  - [ ] Отображение всех сохраненных слов пользователя
  - [ ] Фильтрация по языку
  - [ ] Поиск по словам
  - [ ] Возможность выбрать слова из списка для генерации

#### 5.9. Улучшение стилей
- [ ] Добавить анимации для переходов
- [ ] Улучшить адаптивность для мобильных устройств
- [ ] Добавить иконки для лучшей визуализации
- [ ] Улучшить цветовую схему

### Критерии завершения этапа
- ✅ Пользователь может загружать аудиофайлы
- ✅ Пользователь может загружать изображения
- ✅ Медиафайлы корректно включаются в карточки
- ✅ Форма удобна в использовании
- ✅ Ошибки отображаются понятно
- ✅ Интерфейс адаптивен

**Ориентировочное время:** 3-4 дня

---

## Этап 6: Интеграция, тестирование и оптимизация

**Цель:** Протестировать все функции, исправить ошибки и оптимизировать производительность.

### Задачи

#### 6.1. Интеграционное тестирование
- [ ] Протестировать полный цикл:
  - [ ] Регистрация → Вход → Ввод слов → Ввод переводов → Загрузка медиа → Генерация → Скачивание
- [ ] Протестировать различные сценарии:
  - [ ] Генерация без медиа
  - [ ] Генерация только с аудио
  - [ ] Генерация только с изображениями
  - [ ] Генерация с обоими типами медиа
- [ ] Протестировать обработку ошибок:
  - [ ] Неверные данные
  - [ ] Сетевые ошибки
  - [ ] Ошибки сервера

#### 6.2. Тестирование Backend
- [ ] Написать unit-тесты для моделей
- [ ] Написать unit-тесты для сериализаторов
- [ ] Написать unit-тесты для views
- [ ] Написать тесты для генерации `.apkg` файлов
- [ ] Проверить покрытие тестами (минимум 70%)

#### 6.3. Тестирование Frontend
- [ ] Протестировать все компоненты
- [ ] Протестировать интеграцию с API
- [ ] Протестировать обработку ошибок
- [ ] Протестировать валидацию форм

#### 6.4. Проверка безопасности
- [ ] Проверить защиту от SQL-инъекций
- [ ] Проверить валидацию входных данных
- [ ] Проверить защиту от CSRF
- [ ] Проверить правильность работы аутентификации
- [ ] Проверить изоляцию данных пользователей

#### 6.5. Оптимизация производительности
- [ ] Оптимизировать запросы к БД (использовать select_related, prefetch_related)
- [ ] Добавить кэширование для часто используемых данных (опционально)
- [ ] Оптимизировать размер медиафайлов перед сохранением
- [ ] Оптимизировать генерацию `.apkg` файлов
- [ ] Проверить время отклика API

#### 6.6. Обработка ошибок
- [ ] Добавить логирование ошибок на Backend
- [ ] Добавить обработку исключений
- [ ] Улучшить сообщения об ошибках для пользователя
- [ ] Добавить fallback для критических ошибок

#### 6.7. Очистка кода
- [ ] Проверить код на соответствие стандартам (PEP 8 для Python, ESLint для TypeScript)
- [ ] Удалить неиспользуемый код
- [ ] Добавить комментарии к сложным участкам
- [ ] Рефакторинг дублирующегося кода

#### 6.8. Тестирование на разных устройствах
- [ ] Протестировать на разных браузерах (Chrome, Firefox, Safari)
- [ ] Протестировать на мобильных устройствах
- [ ] Проверить адаптивность интерфейса

### Критерии завершения этапа
- ✅ Все функции протестированы и работают
- ✅ Критические ошибки исправлены
- ✅ Производительность приемлема
- ✅ Код чистый и документированный
- ✅ Безопасность проверена

**Ориентировочное время:** 2-3 дня

---

## Этап 7: Деплой и финализация

**Цель:** Развернуть приложение для использования и завершить документацию.

### Задачи

#### 7.1. Подготовка к деплою
- [ ] Настроить переменные окружения для production
- [ ] Отключить DEBUG режим
- [ ] Настроить ALLOWED_HOSTS
- [ ] Настроить статические файлы (collectstatic)
- [ ] Настроить медиафайлы для production

#### 7.2. Настройка сервера
- [ ] Выбрать хостинг (например, DigitalOcean, AWS, или локальный сервер)
- [ ] Установить необходимые зависимости на сервере
- [ ] Настроить PostgreSQL на сервере
- [ ] Настроить веб-сервер (Nginx)
- [ ] Настроить WSGI сервер (Gunicorn)

#### 7.3. Деплой Backend
- [ ] Загрузить код на сервер
- [ ] Настроить виртуальное окружение
- [ ] Применить миграции
- [ ] Создать суперпользователя
- [ ] Настроить Gunicorn
- [ ] Настроить Nginx для проксирования
- [ ] Протестировать доступность API

#### 7.4. Деплой Frontend
- [ ] Собрать production build (`npm run build`)
- [ ] Настроить Nginx для раздачи статических файлов
- [ ] Настроить проксирование API запросов
- [ ] Протестировать работу приложения

#### 7.5. Настройка домена и SSL
- [ ] Настроить доменное имя (опционально)
- [ ] Настроить SSL сертификат (Let's Encrypt)
- [ ] Настроить редиректы с HTTP на HTTPS

#### 7.6. Мониторинг и логирование
- [ ] Настроить логирование на сервере
- [ ] Настроить мониторинг ошибок (опционально)
- [ ] Настроить резервное копирование БД

#### 7.7. Документация
- [ ] Обновить README.md с инструкциями по деплою
- [ ] Создать документацию для пользователей (как использовать приложение)
- [ ] Создать документацию для разработчиков (если нужно)
- [ ] Добавить скриншоты интерфейса

#### 7.8. Финальное тестирование
- [ ] Протестировать все функции на production сервере
- [ ] Протестировать с несколькими пользователями
- [ ] Проверить производительность под нагрузкой
- [ ] Исправить найденные проблемы

#### 7.9. Подготовка для пользователей
- [ ] Создать аккаунты для всех пользователей (или инструкции по регистрации)
- [ ] Подготовить инструкцию по использованию
- [ ] Провести демонстрацию приложения

### Критерии завершения этапа
- ✅ Приложение развернуто и доступно
- ✅ Все функции работают на production
- ✅ Документация завершена
- ✅ Пользователи могут начать использовать приложение

**Ориентировочное время:** 2-3 дня

---

## Общая временная оценка

- **Этап 1:** 1-2 дня
- **Этап 2:** 2-3 дня
- **Этап 3:** 3-4 дня
- **Этап 4:** 3-4 дня
- **Этап 5:** 3-4 дня
- **Этап 6:** 2-3 дня
- **Этап 7:** 2-3 дня

**Итого:** 16-23 дня (примерно 3-4 недели при работе в свободное время)

---

## Приоритеты и зависимости

### Критический путь (необходимо для базовой функциональности):
1. Этап 1 → Этап 2 → Этап 3 → Этап 4

### Можно делать параллельно:
- Этап 5 можно начинать после завершения Этапа 4
- Некоторые задачи из Этапа 6 можно выполнять параллельно с разработкой

### Рекомендации:
- Сначала реализовать базовую функциональность (Этапы 1-4)
- Затем добавить улучшения (Этап 5)
- После этого тестировать и оптимизировать (Этап 6)
- В конце деплоить (Этап 7)

---

## Заметки

- План может корректироваться в процессе разработки
- Некоторые задачи могут быть упрощены или пропущены в зависимости от приоритетов
- Рекомендуется делать коммиты после завершения каждой задачи
- Важно тестировать на каждом этапе, а не только в конце

