# Техническое задание для Frontend разработчика

**Проект:** Anki Card Generator  
**Версия:** 2.0  
**Обновлено:** 5 декабря 2025  
**Статус Backend:** ✅ Все этапы завершены

---

## О проекте

**Anki Card Generator** — веб-приложение для автоматической генерации карточек Anki с изображениями и аудио. Пользователь вводит список слов на изучаемом языке, система генерирует переводы, картинки через DALL-E 3 и озвучку через TTS, а затем создает готовый .apkg файл для импорта в Anki.

**Ключевые функции:**
- Аутентификация (регистрация/вход)
- Профиль пользователя с настройками языков и темы
- Управление колодами слов (создание, редактирование, хранение)
- Генерация карточек с медиа (изображения, аудио)
- **Выбор провайдера генерации изображений** (OpenAI DALL-E 3 или Google Gemini)
- Три стиля генерации изображений (минималистичный, сбалансированный, творческий)
- Два режима работы (простой и расширенный)
- Система токенов для ограничения генерации

---

## Подключение к Backend (ngrok)

Для подключения к бэкенду используется **ngrok** — туннель, который делает локальный Django доступным через публичный URL. Это необходимо, т.к. Figma Make работает в облаке и не имеет прямого доступа к `localhost`.

### Схема работы

```
┌───────────────────────────────────────────────────────────────────┐
│                                                                   │
│   Figma Make (Frontend в облаке)                                  │
│         │                                                         │
│         │ HTTPS запросы                                           │
│         ▼                                                         │
│   https://get-anki.fan.ngrok.app/api/...                          │
│         │                                                         │
│         │ (через интернет)                                        │
│         ▼                                                         │
│   ngrok сервер → localhost:8000 (локальный Django)                │
│         │                                                         │
│         │ Django обрабатывает запрос                              │
│         ▼                                                         │
│   JSON ответ → ngrok → обратно во Frontend                        │
│                                                                   │
└───────────────────────────────────────────────────────────────────┘
```

### Текущий публичный URL бэкенда (ПОСТОЯННЫЙ)

```
https://get-anki.fan.ngrok.app
```

> ✅ **Это платный фиксированный домен ngrok — URL НЕ изменится при перезапуске!**

### ⚠️ КРИТИЧНО: Trailing Slash

**ВСЕ endpoints Django требуют `/` в конце URL!**

```typescript
// ❌ НЕПРАВИЛЬНО — вернёт ошибку 500
api.post('/auth/login', data)
api.get('/cards/decks')

// ✅ ПРАВИЛЬНО
api.post('/auth/login/', data)
api.get('/cards/decks/')
```

### Конфигурация API клиента

В файле настройки API установите **полный URL ngrok**:

```typescript
import axios from 'axios';

const api = axios.create({
  baseURL: 'https://get-anki.fan.ngrok.app/api/',  // Постоянный ngrok URL!
  headers: {
    'Content-Type': 'application/json',
  },
});

// Интерцептор для добавления токена
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Token ${token}`;
  }
  return config;
});

// Интерцептор для обработки 401
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
```

### Проверка подключения

После настройки проверьте работу:

1. **API доступен:** http://localhost/api/ → должен вернуть список endpoints
2. **Admin доступен:** http://localhost/admin/ → страница входа Django
3. **Фронтенд доступен:** http://localhost/ → ваше React приложение

---

## Содержание

1. [Этап 1: Инициализация проекта](#этап-1-инициализация-проекта)
2. [Этап 2: Маршрутизация и API клиент](#этап-2-маршрутизация-и-api-клиент)
3. [Этап 3: Аутентификация](#этап-3-аутентификация)
4. [Этап 4: Layout и навигация](#этап-4-layout-и-навигация)
5. [Этап 5: Темизация](#этап-5-темизация)
6. [Этап 6: Система уведомлений](#этап-6-система-уведомлений)
7. [Этап 7: Профиль пользователя](#этап-7-профиль-пользователя)
8. [Этап 8: Система токенов](#этап-8-система-токенов)
9. [Этап 9: Страница колод (Dashboard)](#этап-9-страница-колод-dashboard)
10. [Этап 10: Редактор колоды](#этап-10-редактор-колоды)
11. [Этап 11: Быстрая генерация — базовый интерфейс](#этап-11-быстрая-генерация--базовый-интерфейс)
12. [Этап 12: Генерация — медиа и стили](#этап-12-генерация--медиа-и-стили)
13. **[Этап 12.1: Выбор провайдера генерации изображений](#этап-121-выбор-провайдера-генерации-изображений)**
14. **[Этап 12.2: Выбор модели Gemini и дробные токены](#этап-122-выбор-модели-gemini-и-дробные-токены)**
15. [Этап 13: Умный ввод и автоанализ слов](#этап-13-умный-ввод-и-автоанализ-слов)
14. **[Этап 13.1: Исправление — Генерация медиа (КРИТИЧНО!)](#этап-131-исправление--генерация-медиа-критично)**
15. **[Этап 13.2: Исправление — Генерация из колоды](#этап-132-исправление--генерация-из-колоды)**
16. **[Этап 13.3: Тестирование генерации](#этап-133-тестирование-генерации)**
17. **[Этап 13.4: Унификация ввода слов в колодах](#этап-134-унификация-ввода-слов-в-колодах)**
18. **[Этап 13.5: Генерация медиа при добавлении слов в колоду](#этап-135-генерация-медиа-при-добавлении-слов-в-колоду)**
19. **[Этап 13.6: Сохранение быстрой генерации в "Мои колоды"](#этап-136-сохранение-быстрой-генерации-в-мои-колоды)**
20. [Этап 14: Предпросмотр медиа](#этап-14-предпросмотр-медиа)
21. [Этап 15: Обработка ошибок](#этап-15-обработка-ошибок)
22. [Этап 16: UX полировка и анимации](#этап-16-ux-полировка-и-анимации)
23. [Этап 17: Оптимизация и финальное тестирование](#этап-17-оптимизация-и-финальное-тестирование)
24. [Этап 18: Режимы работы Simple/Advanced (опционально)](#этап-18-режимы-работы-simpleadvanced-опционально)

---

## Этап 1: Инициализация проекта

**Цель:** Создать базовую структуру React-проекта со всеми необходимыми зависимостями и настройками. После этого этапа проект должен запускаться и отображать пустую страницу с подключенными стилями.

**Ориентировочное время:** 1 день

### Задачи

1. Создать проект с помощью Vite:
   ```bash
   npm create vite@latest frontend -- --template react-ts
   ```

2. Установить и настроить TailwindCSS:
   - Файл `tailwind.config.js`
   - Файл `postcss.config.js`
   - Подключить в `index.css`

3. Установить Shadcn/ui:
   - Инициализировать через CLI
   - Установить базовые компоненты: Button, Input, Card

4. Создать структуру папок:
   ```
   src/
   ├── components/    # Переиспользуемые компоненты
   │   └── ui/        # Shadcn компоненты
   ├── pages/         # Страницы приложения
   ├── services/      # API и внешние сервисы
   ├── contexts/      # React контексты
   ├── hooks/         # Кастомные хуки
   ├── types/         # TypeScript типы
   ├── utils/         # Утилиты
   └── styles/        # Дополнительные стили
   ```

5. Создать базовые TypeScript типы в `types/index.ts`:
   ```typescript
   // User
   interface User {
     id: number;
     username: string;
     email: string;
     first_name: string;
     last_name: string;
     avatar: string | null;
     native_language: string;
     learning_language: string;
     theme: 'light' | 'dark';
     mode: 'simple' | 'advanced';
   }

   // Word
   interface Word {
     id: number;
     original_word: string;
     translation: string;
     language: string;
     audio_file: string | null;
     image_file: string | null;
   }

   // Deck
   interface Deck {
     id: number;
     name: string;
     cover: string | null;
     target_lang: string;
     source_lang: string;
     words: Word[];
     words_count: number;
     created_at: string;
     updated_at: string;
   }

   // API responses
   interface AuthResponse {
     token: string;
     user: User;
   }
   ```

### Чек-лист

- [ ] Проект создан командой Vite
- [ ] `npm run dev` запускает проект без ошибок
- [ ] TypeScript работает (проверить наведением на переменную)
- [ ] TailwindCSS подключен (проверить класс `bg-blue-500`)
- [ ] Shadcn/ui установлен (компонент Button рендерится)
- [ ] Структура папок создана
- [ ] Базовые типы описаны в `types/index.ts`

---

## Этап 2: Маршрутизация и API клиент

**Цель:** Настроить навигацию между страницами и создать централизованный API клиент с обработкой авторизации. После этого этапа должны работать переходы между страницами-заглушками.

**Ориентировочное время:** 1 день

### Задачи

1. Установить React Router:
   ```bash
   npm install react-router-dom
   ```

2. Настроить маршруты в `App.tsx`:
   - `/login` — страница входа
   - `/register` — страница регистрации
   - `/` — главная страница (генерация)
   - `/profile` — профиль пользователя
   - `/decks` — список колод
   - `/decks/:id` — редактор колоды
   - `*` — страница 404 (пока заглушка)

3. Создать страницы-заглушки в `pages/`:
   - `LoginPage.tsx`
   - `RegisterPage.tsx`
   - `MainPage.tsx`
   - `ProfilePage.tsx`
   - `DecksPage.tsx`
   - `DeckEditorPage.tsx`
   - `NotFoundPage.tsx`

4. Установить Axios:
   ```bash
   npm install axios
   ```

5. Создать API клиент в `services/api.ts`:
   - Базовый URL: `http://localhost:8000/api/`
   - Интерцептор запросов: добавлять токен из localStorage
   - Интерцептор ответов: при 401 — удалять токен и редиректить на `/login`

6. Создать компонент `ProtectedRoute`:
   - Проверяет наличие токена в localStorage
   - Если нет токена — редирект на `/login`
   - Если есть — рендерит children

### Чек-лист

- [ ] React Router установлен
- [ ] Переходы между страницами работают
- [ ] Все маршруты ведут на соответствующие страницы-заглушки
- [ ] Axios настроен с базовым URL
- [ ] Интерцептор добавляет заголовок `Authorization: Token <token>`
- [ ] Интерцептор обрабатывает 401 и редиректит на login
- [ ] ProtectedRoute защищает приватные маршруты
- [ ] При прямом переходе на защищенную страницу без токена — редирект на login

---

## Этап 3: Аутентификация

**Цель:** Реализовать полноценную аутентификацию пользователей. После этого этапа пользователь может зарегистрироваться, войти и выйти из системы.

**Ориентировочное время:** 2 дня

### Задачи

1. Создать `AuthContext` в `contexts/AuthContext.tsx`:
   - Состояние: `user`, `token`, `isLoading`, `isAuthenticated`
   - Методы: `login()`, `register()`, `logout()`, `loadUser()`
   - При инициализации: проверить токен в localStorage, загрузить профиль

2. Реализовать страницу входа (`LoginPage.tsx`):
   - Поля: Username, Password
   - Кнопка "Войти" с индикатором загрузки
   - Ссылка на регистрацию
   - Валидация: пустые поля, минимальная длина
   - Обработка ошибок: неверные данные, ошибка сети
   - После успешного входа: сохранить токен, редирект на главную

3. Реализовать страницу регистрации (`RegisterPage.tsx`):
   - Поля: Username, Email, Password, Confirm Password
   - Валидация: пустые поля, формат email, совпадение паролей, минимальная длина
   - Обработка ошибок: username занят, email занят
   - После успешной регистрации: редирект на страницу входа

4. Добавить API методы в `services/api.ts`:
   ```typescript
   // POST /api/auth/register/
   register(data: { username: string; email: string; password: string }): Promise<AuthResponse>
   
   // POST /api/auth/login/
   login(data: { username: string; password: string }): Promise<AuthResponse>
   
   // GET /api/user/profile/
   getProfile(): Promise<User>
   ```

### Чек-лист

- [ ] AuthContext создан и экспортируется
- [ ] При загрузке приложения проверяется токен в localStorage
- [ ] Страница входа отображает форму
- [ ] Валидация полей работает (пустые поля, длина)
- [ ] При неверном логине/пароле показывается ошибка
- [ ] После успешного входа токен сохраняется в localStorage
- [ ] После успешного входа происходит редирект на главную
- [ ] Страница регистрации отображает форму
- [ ] Валидация регистрации работает (email, пароли совпадают)
- [ ] При занятом username/email показывается ошибка
- [ ] После успешной регистрации редирект на страницу входа
- [ ] Выход из системы очищает токен и редиректит на login
- [ ] Ошибки сети обрабатываются и показываются пользователю

---

## Этап 4: Layout и навигация

**Цель:** Создать общий каркас приложения с шапкой и навигацией. После этого этапа все страницы отображаются внутри единого Layout с навигацией.

**Ориентировочное время:** 1 день

### Задачи

1. Создать компонент `Layout` в `components/Layout.tsx`:
   - Header (шапка)
   - Main (основной контент — children)
   - Опционально: Footer

2. Создать компонент `Header`:
   - Логотип приложения (слева)
   - Навигация (центр или справа):
     - "Создать" — ссылка на главную
     - "Мои колоды" — ссылка на /decks
   - Блок пользователя (справа):
     - Аватар (или иконка пользователя)
     - Имя пользователя
     - Выпадающее меню: Профиль, Выйти

3. Обернуть защищенные страницы в Layout:
   - MainPage
   - ProfilePage
   - DecksPage
   - DeckEditorPage

4. Адаптивность:
   - На мобильных: бургер-меню или упрощенная навигация

### Чек-лист

- [ ] Компонент Layout создан
- [ ] Header отображается на всех защищенных страницах
- [ ] Логотип кликабелен и ведет на главную
- [ ] Навигация содержит ссылки: Создать, Мои колоды
- [ ] Текущая страница выделена в навигации
- [ ] Блок пользователя отображает аватар/иконку и имя
- [ ] Выпадающее меню работает (Профиль, Выйти)
- [ ] Клик на "Профиль" ведет на /profile
- [ ] Клик на "Выйти" выполняет logout
- [ ] На мобильных навигация адаптируется

---

## Этап 5: Темизация

**Цель:** Реализовать переключение между светлой и темной темой с сохранением выбора. После этого этапа пользователь может переключать тему, и она сохраняется при перезагрузке.

**Ориентировочное время:** 1 день

### Задачи

1. Создать `ThemeContext` в `contexts/ThemeContext.tsx`:
   - Состояние: `theme` ('light' | 'dark')
   - Метод: `toggleTheme()`, `setTheme()`
   - При инициализации: брать из профиля пользователя или localStorage

2. Настроить Tailwind для dark mode:
   - В `tailwind.config.js`: `darkMode: 'class'`
   - Добавлять класс `dark` на `<html>`

3. Добавить переключатель темы в Header:
   - Иконка солнца/луны
   - При клике — переключение темы

4. Обновить стили компонентов для dark mode:
   - Фоны: `bg-white dark:bg-gray-900`
   - Текст: `text-gray-900 dark:text-gray-100`
   - И т.д.

5. Синхронизация с профилем:
   - При изменении темы — отправлять на сервер (PATCH /api/user/profile/)
   - При загрузке профиля — применять тему из профиля

### Чек-лист

- [ ] ThemeContext создан и экспортируется
- [ ] Переключатель темы отображается в Header
- [ ] При клике тема переключается мгновенно
- [ ] Класс `dark` добавляется/удаляется на `<html>`
- [ ] Все компоненты корректно отображаются в обеих темах
- [ ] Тема сохраняется в localStorage
- [ ] При перезагрузке страницы тема восстанавливается
- [ ] Тема синхронизируется с профилем пользователя на сервере

---

## Этап 6: Система уведомлений

**Цель:** Создать глобальную систему уведомлений (Toast) для отображения успешных действий и ошибок. После этого этапа все важные действия сопровождаются уведомлениями.

**Ориентировочное время:** 1 день

### Задачи

1. Установить библиотеку для Toast (рекомендуется sonner или react-hot-toast):
   ```bash
   npm install sonner
   ```

2. Создать `ToastContext` или использовать встроенный API библиотеки

3. Интегрировать Toast в приложение:
   - Добавить `<Toaster />` в корень приложения
   - Создать хелпер-функции: `showSuccess()`, `showError()`, `showInfo()`

4. Стилизовать Toast:
   - Успех: зеленый
   - Ошибка: красный
   - Информация: синий
   - Поддержка dark mode

5. Интегрировать с существующими действиями:
   - Успешный вход: "Добро пожаловать, {username}!"
   - Успешная регистрация: "Аккаунт создан. Войдите в систему."
   - Ошибка входа: "Неверное имя пользователя или пароль"
   - Ошибка сети: "Не удалось подключиться к серверу"

### Чек-лист

- [ ] Библиотека Toast установлена
- [ ] `<Toaster />` добавлен в App
- [ ] Хелпер-функции созданы и доступны
- [ ] При успешном входе показывается уведомление
- [ ] При ошибке входа показывается уведомление
- [ ] При успешной регистрации показывается уведомление
- [ ] Уведомления стилизованы и поддерживают dark mode
- [ ] Уведомления автоматически исчезают через несколько секунд
- [ ] Можно закрыть уведомление вручную

---

## Этап 7: Профиль пользователя

**Цель:** Создать страницу профиля с возможностью редактирования личных данных, аватара и настроек. После этого этапа пользователь может полностью настроить свой профиль.

**Ориентировочное время:** 2-3 дня

### Задачи

1. Реализовать страницу профиля (`ProfilePage.tsx`):
   - Заголовок: "Настройки профиля"
   - Форма редактирования

2. Блок личных данных:
   - Поле "Имя" (first_name)
   - Поле "Фамилия" (last_name)

3. Блок аватара:
   - Текущий аватар (или placeholder)
   - Кнопка "Загрузить фото" (input type="file")
   - Поддержка drag-and-drop (опционально)
   - Предпросмотр выбранного изображения
   - Кнопка "Удалить фото" (если аватар есть)
   - Валидация: формат (JPG, PNG, WebP), размер (макс. 5MB)

4. Блок языков:
   - Селектор "Родной язык" (native_language): Русский, English, Português, Deutsch
   - Селектор "Язык изучения" (learning_language): Português, Deutsch
   - Отображение флагов стран рядом с языками

5. Блок настроек:
   - Переключатель темы (дублирует Header, но здесь более явный)

6. Кнопки действий:
   - "Сохранить" — отправляет PATCH /api/user/profile/
   - "Отмена" — сбрасывает изменения к исходным

7. Добавить API методы:
   ```typescript
   // PATCH /api/user/profile/
   updateProfile(data: FormData | Partial<User>): Promise<User>
   ```

8. Обновить Header:
   - Отображать актуальный аватар
   - Отображать first_name или username

### Чек-лист

- [ ] Страница профиля доступна по маршруту /profile
- [ ] Форма отображает текущие данные пользователя
- [ ] Поля "Имя" и "Фамилия" редактируются
- [ ] Аватар отображается (или placeholder)
- [ ] Кнопка "Загрузить фото" открывает выбор файла
- [ ] Предпросмотр выбранного изображения работает
- [ ] Валидация формата файла работает (ошибка при неверном формате)
- [ ] Валидация размера файла работает (ошибка при > 5MB)
- [ ] Кнопка "Удалить фото" удаляет аватар
- [ ] Селекторы языков работают, отображают флаги
- [ ] Кнопка "Сохранить" отправляет данные на сервер
- [ ] Индикатор загрузки во время сохранения
- [ ] Уведомление об успешном сохранении
- [ ] Кнопка "Отмена" сбрасывает изменения
- [ ] Аватар в Header обновляется после сохранения
- [ ] Язык изучения из профиля используется как дефолтный при генерации

---

## Этап 8: Система токенов

**Цель:** Реализовать отображение баланса токенов и блокировку генерации при нулевом балансе. После этого этапа пользователь видит свой баланс и не может генерировать при его отсутствии.

**Ориентировочное время:** 1-2 дня

### Задачи

1. Добавить типы:
   ```typescript
   interface TokenBalance {
     balance: number;
   }
   
   interface TokenTransaction {
     id: number;
     transaction_type: 'earned' | 'spent' | 'refund';
     amount: number;
     description: string;
     created_at: string;
   }
   ```

2. Создать компонент `TokenBalanceWidget`:
   - Иконка монеты/токена
   - Отображение числа токенов
   - Анимация при изменении (опционально)
   - Предупреждение при низком балансе (< 10)

3. Добавить виджет в Header:
   - Разместить рядом с профилем пользователя

4. Создать модальное окно "Недостаточно токенов":
   - Информация о необходимости пополнения
   - Текущий баланс
   - Кнопка "Понятно" (закрывает модальное окно)

5. Добавить API методы:
   ```typescript
   // GET /api/tokens/balance/
   getTokenBalance(): Promise<TokenBalance>
   
   // GET /api/tokens/transactions/
   getTokenTransactions(): Promise<TokenTransaction[]>
   ```

6. Логика блокировки:
   - Перед генерацией проверять баланс
   - Если баланс = 0, показывать модальное окно
   - Кнопка генерации disabled при нулевом балансе

7. Обновление баланса:
   - После успешной генерации — обновлять баланс
   - При загрузке страницы — загружать актуальный баланс

### Чек-лист

- [ ] Компонент TokenBalanceWidget создан
- [ ] Виджет отображается в Header
- [ ] Баланс загружается при инициализации приложения
- [ ] Иконка токена отображается рядом с числом
- [ ] При балансе < 10 показывается предупреждение (цвет/иконка)
- [ ] При балансе = 0 кнопка генерации disabled
- [ ] При попытке генерации с нулевым балансом — модальное окно
- [ ] Модальное окно можно закрыть
- [ ] После генерации баланс обновляется
- [ ] Анимация изменения баланса работает (опционально)

---

## Этап 9: Страница колод (Dashboard)

**Цель:** Создать страницу со списком всех колод пользователя и возможностью создания/удаления. После этого этапа пользователь может управлять своими колодами.

**Ориентировочное время:** 2 дня

### Задачи

1. Реализовать страницу колод (`DecksPage.tsx`):
   - Заголовок: "Мои колоды"
   - Кнопка "Создать колоду"
   - Сетка карточек колод

2. Создать компонент `DeckCard`:
   - Обложка (или placeholder)
   - Название колоды
   - Количество слов
   - Дата последнего обновления
   - Меню действий: Редактировать, Генерировать, Удалить

3. Создать модальное окно "Создать колоду":
   - Поле "Название колоды"
   - Селектор "Язык изучения"
   - Селектор "Язык перевода"
   - Кнопки: Создать, Отмена

4. Создать модальное окно подтверждения удаления:
   - Текст: "Вы уверены, что хотите удалить колоду '{name}'?"
   - Кнопки: Удалить, Отмена

5. Добавить API методы:
   ```typescript
   // GET /api/cards/decks/
   getDecks(): Promise<Deck[]>
   
   // POST /api/cards/decks/
   createDeck(data: { name: string; target_lang: string; source_lang: string }): Promise<Deck>
   
   // DELETE /api/cards/decks/{id}/
   deleteDeck(id: number): Promise<void>
   ```

6. Пустое состояние:
   - Если колод нет: "У вас пока нет колод. Создайте первую!"

### Чек-лист

- [ ] Страница доступна по маршруту /decks
- [ ] Список колод загружается при открытии страницы
- [ ] Карточки колод отображаются в виде сетки
- [ ] Карточка содержит: название, кол-во слов, дату
- [ ] Кнопка "Создать колоду" открывает модальное окно
- [ ] Модальное окно создания содержит все поля
- [ ] Новая колода создается и появляется в списке
- [ ] Уведомление об успешном создании
- [ ] Кнопка "Редактировать" ведет на /decks/:id
- [ ] Кнопка "Удалить" открывает подтверждение
- [ ] После подтверждения колода удаляется
- [ ] Уведомление об успешном удалении
- [ ] Пустое состояние отображается когда колод нет
- [ ] Skeleton loader во время загрузки списка

---

## Этап 10: Редактор колоды

**Цель:** Создать страницу редактирования колоды с возможностью добавления/удаления слов. После этого этапа пользователь может редактировать содержимое колод.

**Ориентировочное время:** 2-3 дня

### Задачи

1. Реализовать страницу редактора (`DeckEditorPage.tsx`):
   - Загрузка колоды по ID из URL
   - Редактируемое название колоды (inline edit)
   - Таблица слов
   - Форма добавления слова
   - Кнопка "Сгенерировать файл"

2. Создать компонент `EditableTitle`:
   - При клике: превращается в input
   - При потере фокуса или Enter: сохраняет
   - При Escape: отменяет

3. Создать компонент `WordsTable`:
   - Колонки: №, Слово, Перевод, Действия
   - Кнопка "Удалить" в каждой строке
   - Пустое состояние: "Добавьте первое слово"

4. Создать компонент `AddWordForm`:
   - Поле "Слово"
   - Поле "Перевод"
   - Кнопка "Добавить"
   - Очистка полей после добавления

5. Функция генерации:
   - Кнопка "Сгенерировать .apkg"
   - Индикатор загрузки
   - Автоматическое скачивание файла

6. Добавить API методы:
   ```typescript
   // GET /api/cards/decks/{id}/
   getDeck(id: number): Promise<Deck>
   
   // PATCH /api/cards/decks/{id}/
   updateDeck(id: number, data: Partial<Deck>): Promise<Deck>
   
   // POST /api/cards/decks/{id}/add_words/
   addWordsToDeck(id: number, words: { word: string; translation: string }[]): Promise<Deck>
   
   // POST /api/cards/decks/{id}/remove_word/
   removeWordFromDeck(id: number, wordId: number): Promise<Deck>
   
   // POST /api/cards/decks/{id}/generate_apkg/
   generateDeckApkg(id: number): Promise<{ file_id: string }>
   
   // GET /api/cards/download/{file_id}/
   downloadDeck(fileId: string): Promise<Blob>
   ```

### Чек-лист

- [ ] Страница доступна по маршруту /decks/:id
- [ ] Данные колоды загружаются при открытии
- [ ] Название колоды отображается и редактируется inline
- [ ] Изменение названия сохраняется на сервер
- [ ] Таблица слов отображается корректно
- [ ] Пустое состояние таблицы работает
- [ ] Форма добавления слова работает
- [ ] Новое слово появляется в таблице без перезагрузки
- [ ] Кнопка "Удалить" удаляет слово из колоды
- [ ] Уведомления при добавлении/удалении слов
- [ ] Кнопка "Сгенерировать .apkg" работает
- [ ] Индикатор загрузки во время генерации
- [ ] Файл скачивается автоматически
- [ ] Ошибки обрабатываются и показываются
- [ ] При попытке генерировать пустую колоду — ошибка

---

## Этап 11: Быстрая генерация — базовый интерфейс

**Цель:** Создать главную страницу для быстрой генерации карточек без сохранения в колоду. После этого этапа пользователь может сгенерировать карточки, введя слова.

**Ориентировочное время:** 2 дня

### Задачи

1. Реализовать главную страницу (`MainPage.tsx`):
   - Заголовок: "Создать карточки"
   - Форма генерации
   - Кнопка генерации
   - Область результатов

2. Создать компонент `WordInput`:
   - Textarea для ввода слов
   - Плейсхолдер: "Введите слова через запятую или с новой строки"
   - Счетчик слов внизу

3. Создать компонент `TranslationTable`:
   - Отображается после ввода слов
   - Колонки: Слово, Перевод
   - Переводы редактируемые
   - Автопарсинг слов из textarea при потере фокуса

4. Добавить поля:
   - Селектор "Язык изучения" (по умолчанию из профиля)
   - Поле "Название колоды" (по умолчанию: "Новая колода")

5. Кнопка генерации:
   - Текст: "Сгенерировать карточки"
   - Состояния: default, loading, disabled
   - Проверка токенов перед генерацией

6. Добавить API метод:
   ```typescript
   // POST /api/cards/generate/
   generateCards(data: {
     words: { word: string; translation: string }[];
     language: string;
     deck_name: string;
   }): Promise<{ file_id: string }>
   ```

### Чек-лист

- [ ] Главная страница отображается по маршруту /
- [ ] Компонент WordInput работает, принимает ввод
- [ ] Счетчик слов обновляется при вводе
- [ ] Слова парсятся при потере фокуса
- [ ] TranslationTable отображает список слов
- [ ] Переводы можно редактировать
- [ ] Селектор языка работает
- [ ] Язык по умолчанию берется из профиля
- [ ] Поле названия колоды работает
- [ ] Кнопка генерации активна только при наличии слов
- [ ] Индикатор загрузки во время генерации
- [ ] Файл .apkg скачивается после генерации
- [ ] Уведомление об успешной генерации
- [ ] Ошибки отображаются пользователю

---

## Этап 12: Генерация — медиа и стили

**Цель:** Добавить управление генерацией медиа и выбор стиля изображений. После этого этапа пользователь может настраивать медиа-контент карточек.

**Ориентировочное время:** 1-2 дня

### Задачи

1. Добавить секцию "Медиа настройки":
   - Чекбокс "Генерировать изображения" (по умолчанию: включен)
   - Чекбокс "Генерировать аудио" (по умолчанию: включен)
   - Иконки рядом с чекбоксами

2. Создать компонент `ImageStyleSelector`:
   - Три карточки стилей:
     - **Минималистичный**: иконка, название, описание "Простое и чистое изображение"
     - **Сбалансированный**: иконка, название, описание "Умеренно детализированная иллюстрация" (по умолчанию)
     - **Творческий**: иконка, название, описание "Яркая и запоминающаяся иллюстрация"
   - Визуальное выделение выбранного стиля
   - Показывать только если чекбокс изображений включен

3. Обновить API запрос генерации:
   ```typescript
   generateCards(data: {
     words: { word: string; translation: string }[];
     language: string;
     deck_name: string;
     generate_images: boolean;
     generate_audio: boolean;
     image_style: 'minimalistic' | 'balanced' | 'creative';
   }): Promise<{ file_id: string }>
   ```

4. Добавить в TranslationTable индикаторы статуса:
   - Колонка "Изображение": иконка (галочка/крестик)
   - Колонка "Аудио": иконка (галочка/крестик)
   - Индикаторы отображаются после генерации (опционально)

### Чек-лист

- [ ] Чекбоксы "Изображения" и "Аудио" отображаются
- [ ] Чекбоксы включены по умолчанию
- [ ] При отключении чекбоксов флаги передаются в API
- [ ] Компонент ImageStyleSelector отображается
- [ ] Три карточки стилей видны
- [ ] Выбранный стиль визуально выделен
- [ ] Стиль "Сбалансированный" выбран по умолчанию
- [ ] При отключении чекбокса изображений, селектор стиля скрыт
- [ ] Выбранный стиль передается в API
- [ ] Адаптивность: на мобильных карточки в колонку

---

## Этап 12.1: Выбор провайдера генерации изображений

**Цель:** Добавить возможность выбора между OpenAI DALL-E 3 и Google Gemini для генерации изображений. Пользователь может выбрать провайдера в настройках профиля.

**Ориентировочное время:** 1-2 дня

**Статус:** ✅ Уже реализовано фронтендом

### Объяснение

Backend поддерживает два провайдера для генерации изображений:
- **OpenAI DALL-E 3** — оригинальный провайдер (по умолчанию), стоимость: 1 токен
- **Google Gemini** — альтернативный провайдер (выбор модели и стоимость — см. [Этап 12.2](#этап-122-выбор-модели-gemini-и-дробные-токены))

Провайдер можно выбрать:
1. **В настройках профиля** — сохраняется как предпочтение пользователя
2. **При генерации** — можно переопределить для конкретной генерации

> **Примечание:** Выбор конкретной модели Gemini и работа с дробными токенами реализованы в [Этапе 12.2](#этап-122-выбор-модели-gemini-и-дробные-токены).

### Задачи

1. **Обновить модель профиля пользователя:**
   - Добавить поле `image_provider` в тип `UserProfile`
   - Тип: `'openai' | 'gemini'`
   - По умолчанию: `'openai'`

2. **Добавить селектор провайдера в настройки профиля:**
   - Создать компонент `ImageProviderSelector`:
     - Две карточки/радио-кнопки:
       - **OpenAI DALL-E 3**: иконка OpenAI, название, описание "Высокое качество, детализированные изображения"
       - **Google Gemini**: иконка Google, название, описание "Альтернативный провайдер, быстрая генерация"
     - Визуальное выделение выбранного провайдера
     - Сохранение через `PATCH /api/user/profile/` с `{ image_provider: 'openai' | 'gemini' }`

3. **Добавить опциональный селектор в форму генерации:**
   - В секции "Медиа настройки" добавить выпадающий список или переключатель:
     - Название: "Провайдер изображений"
     - Опции: "Использовать из профиля" (по умолчанию), "OpenAI DALL-E 3", "Google Gemini"
   - Если выбрано "Использовать из профиля" — не передавать `provider` в API
   - Если выбран конкретный провайдер — передавать `provider: 'openai' | 'gemini'` в API

4. **Обновить API методы:**
   ```typescript
   // Обновить тип для генерации изображения
   interface ImageGenerationRequest {
     word: string;
     translation: string;
     language: 'pt' | 'de';
     image_style?: 'minimalistic' | 'balanced' | 'creative';
     provider?: 'openai' | 'gemini'; // Опционально, если не указан - берется из user.image_provider
     word_id?: number;
   }
   
   // Обновить тип профиля
   interface UserProfile {
     // ... существующие поля
     image_provider: 'openai' | 'gemini';
     // gemini_model будет добавлен в Этапе 12.2
   }
   ```

5. **Обновить компонент генерации изображений:**
   - При вызове `POST /api/media/generate-image/` передавать `provider`, если он указан
   - Логировать используемый провайдер для отладки

6. **Добавить индикатор провайдера (опционально):**
   - В списке сгенерированных изображений показывать маленькую иконку провайдера
   - Или в логах/консоли показывать, какой провайдер использовался

### Чек-лист

- [ ] Поле `image_provider` добавлено в тип `UserProfile`
- [ ] Компонент `ImageProviderSelector` создан и отображается в настройках профиля
- [ ] Две опции провайдера видны и работают
- [ ] Выбранный провайдер сохраняется через API профиля
- [ ] При загрузке профиля провайдер восстанавливается
- [ ] В форме генерации добавлен селектор провайдера (опционально)
- [ ] Параметр `provider` передается в API генерации изображений (если указан)
- [ ] Если `provider` не указан, используется провайдер из профиля пользователя
- [ ] Оба провайдера работают корректно
- [ ] Адаптивность: селектор корректно отображается на мобильных

### API Reference

**Обновленный endpoint генерации изображения:**
```
POST /api/media/generate-image/
```

**Тело запроса:**
```json
{
  "word": "casa",
  "translation": "дом",
  "language": "pt",
  "image_style": "balanced",
  "provider": "gemini",  // Опционально: 'openai' | 'gemini'
  "word_id": 123         // Опционально
}
```

**Обновленный endpoint профиля:**
```
PATCH /api/user/profile/
```

**Тело запроса:**
```json
{
  "image_provider": "gemini"  // 'openai' | 'gemini'
}
```

---

## Этап 12.2: Выбор модели Gemini и дробные токены

**Цель:** Добавить возможность выбора между двумя моделями Gemini (быстрая и новая) с разной стоимостью в токенах. Реализовать поддержку дробных токенов (0.5 токена).

**Ориентировочное время:** 1-2 дня

### Объяснение

Backend теперь поддерживает две модели Gemini для генерации изображений:
- **Gemini Flash (gemini-2.5-flash-image)** — быстрая модель (~4.7 сек), стоимость: **0.5 токена**
- **Nano Banana Pro (nano-banana-pro-preview)** — новая модель (~12.6 сек), стоимость: **1 токен**

Система токенов теперь поддерживает дробные значения:
- Баланс хранится в БД как целое число (внутренний формат: 2 единицы = 1 токен)
- При отображении пользователю конвертируется: `баланс / 2.0`
- При списании: `стоимость * 2` (0.5 токена = 1 единица, 1 токен = 2 единицы)

### Задачи

1. **Обновить тип профиля пользователя:**
   ```typescript
   interface UserProfile {
     // ... существующие поля
     image_provider: 'openai' | 'gemini';
     gemini_model: 'gemini-2.5-flash-image' | 'nano-banana-pro-preview'; // Новое поле
   }
   ```

2. **Добавить селектор модели Gemini в настройки профиля:**
   - Показывать только если `image_provider === 'gemini'`
   - Создать компонент `GeminiModelSelector`:
     - Две карточки/радио-кнопки:
       - **Gemini Flash (быстрая)**: 
         - Иконка ⚡
         - Название: "Gemini Flash"
         - Описание: "Быстрая генерация ~4.7 сек"
         - Стоимость: **0.5 токена** (выделить зеленым цветом)
       - **Nano Banana Pro (новая)**:
         - Иконка 🆕
         - Название: "Nano Banana Pro"
         - Описание: "Новая модель, лучшее качество ~12.6 сек"
         - Стоимость: **1 токен**
     - Визуальное выделение выбранной модели
     - Сохранение через `PATCH /api/user/profile/` с `{ gemini_model: 'gemini-2.5-flash-image' | 'nano-banana-pro-preview' }`

3. **Обновить отображение баланса токенов:**
   - API теперь возвращает дробные значения (например, 5.5 токенов)
   - Обновить компонент отображения баланса для поддержки дробных значений
   - Форматирование: `balance.toFixed(1)` для отображения одной десятичной цифры
   - Пример: `5.5 токенов` вместо `5 токенов`

4. **Обновить API методы:**
   ```typescript
   // Обновить тип для генерации изображения
   interface ImageGenerationRequest {
     word: string;
     translation: string;
     language: 'pt' | 'de';
     image_style?: 'minimalistic' | 'balanced' | 'creative';
     provider?: 'openai' | 'gemini';
     gemini_model?: 'gemini-2.5-flash-image' | 'nano-banana-pro-preview'; // Новое поле
     word_id?: number;
   }
   
   // Обновить тип профиля
   interface UserProfile {
     // ... существующие поля
     image_provider: 'openai' | 'gemini';
     gemini_model: 'gemini-2.5-flash-image' | 'nano-banana-pro-preview';
   }
   
   // Обновить тип баланса
   interface TokenBalance {
     balance: number; // Теперь может быть дробным (например, 5.5)
   }
   ```

5. **Обновить отображение стоимости генерации:**
   - При выборе модели Gemini показывать стоимость:
     - "Gemini Flash: 0.5 токена" (зеленым цветом)
     - "Nano Banana Pro: 1 токен"
   - При выборе OpenAI: "1 токен"
   - Обновлять стоимость динамически при изменении выбора модели

6. **Обновить проверку баланса:**
   - При проверке достаточности токенов учитывать дробные значения
   - Показывать сообщение: "Требуется: 0.5 токена, доступно: 2.5 токенов"
   - Блокировать генерацию, если баланс меньше требуемой стоимости

7. **Обновить историю транзакций (опционально):**
   - Отображать дробные значения в истории транзакций
   - Форматирование: `-0.5 токенов` или `+1.0 токенов`

### Чек-лист

- [ ] Поле `gemini_model` добавлено в тип `UserProfile`
- [ ] Компонент `GeminiModelSelector` создан и отображается в настройках профиля
- [ ] Селектор модели показывается только при `image_provider === 'gemini'`
- [ ] Две опции модели видны с правильными описаниями и стоимостью
- [ ] Выбранная модель сохраняется через API профиля
- [ ] При загрузке профиля модель восстанавливается
- [ ] Баланс токенов отображается с поддержкой дробных значений (например, 5.5)
- [ ] Стоимость генерации обновляется динамически при выборе модели
- [ ] Параметр `gemini_model` передается в API генерации изображений (если указан)
- [ ] Если `gemini_model` не указан, используется модель из профиля пользователя
- [ ] Проверка баланса работает с дробными значениями
- [ ] Сообщения об ошибках показывают дробные значения корректно
- [ ] История транзакций отображает дробные значения (опционально)
- [ ] Адаптивность: селектор корректно отображается на мобильных

### API Reference

**Обновленный endpoint генерации изображения:**
```
POST /api/media/generate-image/
```

**Тело запроса:**
```json
{
  "word": "casa",
  "translation": "дом",
  "language": "pt",
  "image_style": "balanced",
  "provider": "gemini",  // Опционально: 'openai' | 'gemini'
  "gemini_model": "gemini-2.5-flash-image",  // Опционально: 'gemini-2.5-flash-image' | 'nano-banana-pro-preview'
  "word_id": 123         // Опционально
}
```

**Обновленный endpoint профиля:**
```
PATCH /api/user/profile/
```

**Тело запроса:**
```json
{
  "image_provider": "gemini",  // 'openai' | 'gemini'
  "gemini_model": "gemini-2.5-flash-image"  // 'gemini-2.5-flash-image' | 'nano-banana-pro-preview'
}
```

**Обновленный endpoint баланса:**
```
GET /api/tokens/balance/
```

**Ответ:**
```json
{
  "balance": 5.5  // Теперь может быть дробным
}
```

### Стоимость генерации изображений

| Провайдер | Модель | Время генерации | Стоимость |
|-----------|--------|------------------|-----------|
| OpenAI | DALL-E 3 | ~10-15 сек | **1 токен** |
| Gemini | Flash (быстрая) | ~4.7 сек | **0.5 токена** |
| Gemini | Nano Banana Pro | ~12.6 сек | **1 токен** |

---

## Этап 13: Умный ввод и автоанализ слов

**Цель:** Улучшить ввод слов с помощью тегов и добавить автоматический анализ/перевод. После этого этапа система может автоматически переводить слова и обрабатывать немецкую специфику.

**Ориентировочное время:** 2-3 дня

### Задачи

1. Создать компонент `WordChipsInput`:
   - Поле ввода с тегами (chips)
   - При вводе запятой или Enter — создание тега
   - Теги: цветной фон, кнопка удаления
   - Редактирование тега по двойному клику
   - Валидация: подсветка странных символов

2. Добавить кнопку "Автоперевод":
   - Отправляет слова на анализ
   - Заполняет пустые переводы автоматически
   - Индикатор загрузки во время анализа

3. Автокоррекция для немецкого:
   - При потере фокуса на поле слова (для немецкого языка)
   - Отправка на /api/cards/process-german-words/
   - Обновление слова (добавление артикля, капитализация)

4. Добавить API методы:
   ```typescript
   // POST /api/cards/analyze-words/
   analyzeWords(data: {
     words: string[];
     learning_language: string;
     native_language: string;
   }): Promise<{ [word: string]: string }>
   
   // POST /api/cards/translate-words/
   translateWords(data: {
     words: string[];
     source_language: string;
     target_language: string;
   }): Promise<{ [word: string]: string }>
   
   // POST /api/cards/process-german-words/
   processGermanWords(data: { words: string[] }): Promise<{ [word: string]: string }>
   ```

### Чек-лист

- [ ] WordChipsInput создан и работает
- [ ] При вводе запятой создается тег
- [ ] При нажатии Enter создается тег
- [ ] Теги отображаются визуально (цветной фон)
- [ ] Тег можно удалить кликом на X
- [ ] Тег можно редактировать двойным кликом
- [ ] Кнопка "Автоперевод" отображается
- [ ] При клике отправляется запрос на анализ
- [ ] Индикатор загрузки во время анализа
- [ ] Пустые переводы заполняются автоматически
- [ ] Заполненные переводы можно редактировать
- [ ] Для немецкого: автокоррекция при потере фокуса
- [ ] Слово обновляется (артикль, регистр)
- [ ] Уведомления об ошибках анализа

---

## Этап 13.1: Исправление — Генерация медиа (КРИТИЧНО!)

**Цель:** Исправить критическую ошибку — сейчас `.apkg` файлы создаются БЕЗ изображений и аудио. Необходимо добавить реальные вызовы к LLM для генерации медиа.

**Проблема:** В этапах 11-12 описано передавать флаги `generate_images: true`, но бэкенд НЕ генерирует медиа автоматически. Он ожидает готовые URL файлов в параметрах `image_files` и `audio_files`.

**Ориентировочное время:** 2-3 дня

### Как должно работать

```
┌─────────────────────────────────────────────────────────────────────┐
│  ШАГ 1: Пользователь нажимает "Сгенерировать"                       │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  ШАГ 2: Для КАЖДОГО слова генерируем медиа (последовательно!)       │
│                                                                     │
│  for (const word of words) {                                        │
│    // 2a. Генерация изображения (3-10 сек на слово)                 │
│    if (generateImages) {                                            │
│      const imgRes = await api.post('/media/generate-image/', {      │
│        word: word.word,                                             │
│        translation: word.translation,                               │
│        language: language,                                          │
│        image_style: imageStyle                                      │
│      });                                                            │
│      imageFiles[word.word] = imgRes.data.image_url;                 │
│    }                                                                │
│                                                                     │
│    // 2b. Генерация аудио (2-3 сек на слово)                        │
│    if (generateAudio) {                                             │
│      const audioRes = await api.post('/media/generate-audio/', {    │
│        word: word.word,                                             │
│        language: language                                           │
│      });                                                            │
│      audioFiles[word.word] = audioRes.data.audio_url;               │
│    }                                                                │
│                                                                     │
│    // Обновить прогресс UI                                          │
│    setProgress(i + 1, words.length);                                │
│  }                                                                  │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  ШАГ 3: Создать колоду с медиа-файлами                              │
│                                                                     │
│  const response = await api.post('/cards/generate/', {              │
│    words: words.map(w => w.word),                                   │
│    translations: { "Hund": "собака", ... },                         │
│    language: "de",                                                  │
│    deck_name: "Моя колода",                                         │
│    image_files: { "Hund": "/media/images/xxx.jpg", ... },  ← ВАЖНО! │
│    audio_files: { "Hund": "/media/audio/yyy.mp3", ... }    ← ВАЖНО! │
│  });                                                                │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  ШАГ 4: Скачать готовый файл                                        │
│                                                                     │
│  GET /api/cards/download/{response.data.file_id}/                   │
└─────────────────────────────────────────────────────────────────────┘
```

### Задачи

1. Создать сервис `mediaService.ts`:
   ```typescript
   // POST /api/media/generate-image/
   generateImage(data: {
     word: string;
     translation: string;
     language: string;
     image_style: 'minimalistic' | 'balanced' | 'creative';
   }): Promise<{ image_url: string; image_id: string }>
   
   // POST /api/media/generate-audio/
   generateAudio(data: {
     word: string;
     language: string;
   }): Promise<{ audio_url: string; audio_id: string }>
   ```

2. Создать функцию `generateMediaForWords()`:
   - Принимает список слов и настройки
   - Последовательно генерирует медиа для каждого слова
   - Возвращает словари `image_files` и `audio_files`
   - Вызывает callback для обновления прогресса

3. Создать компонент `GenerationProgress`:
   - Отображает текущий этап: "Генерация изображений: 3/10"
   - Прогресс-бар
   - Название текущего слова
   - Кнопка "Отмена" (опционально)

4. Обновить функцию генерации в `MainPage.tsx`:
   - Сначала вызвать `generateMediaForWords()`
   - Затем вызвать `/cards/generate/` с полученными файлами
   - Показывать `GenerationProgress` во время генерации

5. Обработка ошибок:
   - Если генерация изображения/аудио для слова провалилась — продолжить с остальными
   - Показать warning: "Не удалось сгенерировать медиа для N слов"

### Важно: Trailing Slash!

⚠️ **ВСЕ endpoints Django требуют `/` в конце URL!**

```typescript
// ❌ НЕПРАВИЛЬНО — вернёт ошибку 500
api.post('/media/generate-image', data)

// ✅ ПРАВИЛЬНО
api.post('/media/generate-image/', data)
```

### Чек-лист

- [ ] Сервис `mediaService.ts` создан
- [ ] Функция `generateImage()` вызывает `/api/media/generate-image/`
- [ ] Функция `generateAudio()` вызывает `/api/media/generate-audio/`
- [ ] Функция `generateMediaForWords()` создана
- [ ] Генерация медиа происходит последовательно (не параллельно!)
- [ ] Компонент `GenerationProgress` создан
- [ ] Прогресс-бар обновляется при генерации
- [ ] Текущее слово отображается
- [ ] При генерации 5 слов ожидаемое время ~1-2 минуты
- [ ] Словари `image_files` и `audio_files` передаются в `/cards/generate/`
- [ ] .apkg файл содержит изображения (проверить в Anki!)
- [ ] .apkg файл содержит аудио (проверить в Anki!)
- [ ] Ошибки генерации отдельных слов не останавливают весь процесс
- [ ] Все URL заканчиваются на `/`

---

## Этап 13.2: Исправление — Генерация из колоды

**Цель:** Применить тот же fix к генерации из сохранённой колоды (этап 10).

**Ориентировочное время:** 1 день

### Задачи

1. Обновить `DeckEditorPage.tsx`:
   - При клике "Сгенерировать .apkg" — проверить наличие медиа у слов
   - Если медиа нет — сгенерировать перед созданием файла

2. Логика:
   ```typescript
   const handleGenerateApkg = async () => {
     // 1. Получить слова без медиа
     const wordsWithoutMedia = deck.words.filter(
       w => !w.image_file || !w.audio_file
     );
     
     // 2. Если есть слова без медиа — сгенерировать
     if (wordsWithoutMedia.length > 0 && (generateImages || generateAudio)) {
       const { imageFiles, audioFiles } = await generateMediaForWords(
         wordsWithoutMedia,
         { generateImages, generateAudio, imageStyle, language: deck.target_lang }
       );
       // Обновить слова в колоде с новыми медиа
     }
     
     // 3. Вызвать генерацию .apkg
     const response = await api.post(`/cards/decks/${deck.id}/generate_apkg/`);
     downloadFile(response.data.file_id);
   };
   ```

3. Добавить чекбоксы на страницу редактора колоды:
   - "Генерировать изображения для слов без картинок"
   - "Генерировать аудио для слов без озвучки"

### Чек-лист

- [ ] При генерации из колоды проверяется наличие медиа
- [ ] Слова без медиа получают сгенерированные файлы
- [ ] Прогресс генерации отображается
- [ ] .apkg из колоды содержит изображения и аудио
- [ ] Чекбоксы генерации медиа работают

---

## Этап 13.3: Тестирование генерации

**Цель:** Убедиться что генерация медиа работает корректно во всех сценариях.

**Ориентировочное время:** 0.5 дня

### Тест-кейсы

1. **Быстрая генерация с 1 словом:**
   - Ввести: "Hund"
   - Перевод: "собака"
   - Включить изображения и аудио
   - Ожидаемое время: ~15 секунд
   - Результат: .apkg с картинкой и аудио

2. **Быстрая генерация с 5 словами:**
   - Ввести 5 немецких слов
   - Ожидаемое время: ~1-2 минуты
   - Прогресс должен обновляться

3. **Генерация только изображений:**
   - Отключить аудио
   - Результат: .apkg только с картинками

4. **Генерация только аудио:**
   - Отключить изображения
   - Результат: .apkg только с аудио

5. **Генерация из колоды:**
   - Открыть существующую колоду
   - Нажать "Сгенерировать .apkg"
   - Результат: .apkg с медиа

6. **Проверка токенов:**
   - За каждое изображение списывается 1 токен
   - За каждое аудио списывается 1 токен
   - Баланс обновляется после генерации

### Чек-лист

- [ ] Тест 1 пройден
- [ ] Тест 2 пройден
- [ ] Тест 3 пройден
- [ ] Тест 4 пройден
- [ ] Тест 5 пройден
- [ ] Тест 6 пройден
- [ ] Все .apkg файлы открываются в Anki
- [ ] Картинки отображаются в карточках Anki
- [ ] Аудио воспроизводится в карточках Anki

---

## Этап 13.4: Унификация ввода слов в колодах

**Цель:** Применить умный ввод (автоперевод, обработка немецких слов) к редактору колод. Сейчас эти функции работают только в быстрой генерации, но не в редакторе колоды.

**Проблема:** В этапе 10 описана простая форма добавления слов (поле "Слово" + поле "Перевод"), а в этапе 13 — умный ввод с автопереводом и обработкой немецких слов. Эти функции должны работать везде одинаково.

**Ориентировочное время:** 1-2 дня

### Что нужно унифицировать

| Функция | Было в редакторе колоды | Должно быть |
|---------|-------------------------|-------------|
| Ввод слов | Простая форма | WordChipsInput (теги) |
| Автоперевод | ❌ Нет | ✅ Кнопка "Автоперевод" |
| Немецкие слова | ❌ Нет | ✅ Автокоррекция (артикль, регистр) |
| Массовое добавление | ❌ По одному | ✅ Несколько слов сразу |

### Задачи

1. Обновить `AddWordForm` в редакторе колоды:
   - Заменить простые поля на `WordChipsInput`
   - Или добавить переключатель "Массовое добавление"

2. Добавить кнопку "Автоперевод" в редактор колоды:
   - При клике — вызов `/api/cards/translate-words/`
   - Заполнение пустых переводов

3. Добавить автокоррекцию немецких слов:
   - При добавлении слова в колоду с `target_lang: "de"`
   - Вызов `/api/cards/process-german-words/`
   - Обновление слова (артикль, капитализация)

4. Переиспользовать компоненты:
   - `WordChipsInput` — использовать и в MainPage, и в DeckEditorPage
   - `AutoTranslateButton` — общий компонент
   - `useGermanWordProcessor` — хук для автокоррекции

### Пример обновлённого flow в редакторе колоды

```
┌─────────────────────────────────────────────────────────────────────┐
│  Редактор колоды "Животные" (немецкий)                              │
│                                                                     │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ Добавить слова:                                               │  │
│  │ ┌─────────────────────────────────────────────────────────┐   │  │
│  │ │ [hund] [x]  [katze] [x]  [vogel] [x]  [_______]         │   │  │
│  │ └─────────────────────────────────────────────────────────┘   │  │
│  │                                                               │  │
│  │ [🔄 Автоперевод]  [➕ Добавить в колоду]                      │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  При добавлении:                                                    │
│  1. "hund" → API → "der Hund" (артикль + капитализация)            │
│  2. Автоперевод → "собака"                                         │
│  3. Слово добавляется в колоду                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Чек-лист

- [ ] В редакторе колоды можно ввести несколько слов сразу
- [ ] WordChipsInput (или аналог) работает в редакторе колоды
- [ ] Кнопка "Автоперевод" есть в редакторе колоды
- [ ] Автоперевод заполняет пустые переводы
- [ ] Для немецких колод работает автокоррекция
- [ ] Слова получают артикли (der/die/das)
- [ ] Существительные капитализируются
- [ ] Компоненты переиспользуются между MainPage и DeckEditorPage
- [ ] UX одинаковый в обоих местах

---

## Этап 13.5: Генерация медиа при добавлении слов в колоду

**Цель:** При добавлении слов в существующую колоду генерировать изображения и аудио так же, как при быстрой генерации.

**Проблема:** Сейчас при добавлении слова в колоду (через редактор) медиа **не генерируется**. Слово сохраняется без картинки и аудио. При экспорте в `.apkg` — карточка получается пустой.

**Ориентировочное время:** 1-2 дня

### Текущее (неправильное) поведение

```
Пользователь добавляет "Hund" в колоду
         ↓
Бэкенд: Word(original_word="Hund", image_file=NULL, audio_file=NULL)
         ↓
При экспорте → .apkg БЕЗ медиа ❌
```

### Правильное поведение

```
Пользователь добавляет "Hund" в колоду
         ↓
Фронтенд: Генерирует изображение → Генерирует аудио
         ↓
Бэкенд: Word(original_word="Hund", image_file="...", audio_file="...")
         ↓
При экспорте → .apkg С медиа ✅
```

### Задачи

1. **Обновить логику добавления слов в `DeckEditorPage.tsx`:**
   ```typescript
   const handleAddWord = async (wordData: WordInput) => {
     setIsGenerating(true);
     setGenerationStatus(`Генерация медиа для "${wordData.word}"...`);
     
     try {
       // 1. Генерация изображения (если включено)
       let imageUrl = null;
       if (generateImages) {
         const imgRes = await mediaService.generateImage({
           word: wordData.word,
           translation: wordData.translation,
           language: deck.target_lang,
           image_style: imageStyle
         });
         imageUrl = imgRes.image_url;
       }
       
       // 2. Генерация аудио (если включено)
       let audioUrl = null;
       if (generateAudio) {
         const audioRes = await mediaService.generateAudio({
           word: wordData.word,
           language: deck.target_lang
         });
         audioUrl = audioRes.audio_url;
       }
       
       // 3. Добавить слово в колоду с медиа
       await api.post(`/cards/decks/${deckId}/add_words/`, {
         original_word: wordData.word,
         translation: wordData.translation,
         language: deck.target_lang,
         image_file: imageUrl,   // ← Передаём URL медиа
         audio_file: audioUrl    // ← Передаём URL медиа
       });
       
       refreshDeck();
       showSuccess(`Слово "${wordData.word}" добавлено с медиа`);
       
     } catch (error) {
       showError(`Ошибка при добавлении слова: ${error.message}`);
     } finally {
       setIsGenerating(false);
     }
   };
   ```

2. **Добавить настройки генерации медиа в редактор колоды:**
   - Чекбокс "Генерировать изображения" (по умолчанию: вкл)
   - Чекбокс "Генерировать аудио" (по умолчанию: вкл)
   - Селектор стиля изображений (minimalistic/balanced/creative)
   - Эти настройки должны быть в header/toolbar редактора

3. **Индикатор генерации:**
   - При добавлении слова показывать: "Генерация изображения для 'Hund'..."
   - Затем: "Генерация аудио для 'Hund'..."
   - Заблокировать форму добавления во время генерации
   - Spinner или progress indicator

4. **Массовое добавление слов:**
   ```typescript
   const handleAddMultipleWords = async (words: WordInput[]) => {
     for (let i = 0; i < words.length; i++) {
       setGenerationStatus(`Обработка слова ${i+1}/${words.length}: "${words[i].word}"`);
       await handleAddWord(words[i]);
     }
   };
   ```

5. **Обновить бэкенд `add_words`** — убедиться, что он принимает `image_file` и `audio_file`:
   - Бэкенд уже поддерживает сохранение этих полей при создании `Word`
   - Нужно проверить, что сериализатор принимает эти поля

### Flow диаграмма

```
┌─────────────────────────────────────────────────────────────────────┐
│  Редактор колоды "Животные"                                         │
│                                                                     │
│  Настройки генерации:                                               │
│  ☑️ Генерировать изображения  [Сбалансированный ▼]                  │
│  ☑️ Генерировать аудио                                              │
│                                                                     │
│  Добавить слово: [Hund___________] [собака_______] [+ Добавить]     │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼ Клик "Добавить"
┌─────────────────────────────────────────────────────────────────────┐
│  ⏳ Генерация изображения для "Hund"...                              │
└─────────────────────────────────────────────────────────────────────┘
                                    │ (3-10 секунд)
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  ⏳ Генерация аудио для "Hund"...                                    │
└─────────────────────────────────────────────────────────────────────┘
                                    │ (2-3 секунды)
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  ✅ Слово "Hund" добавлено в колоду                                  │
│                                                                     │
│  Слова в колоде:                                                    │
│  ┌──────────────────────────────────────────────────────────────┐   │
│  │ 🖼️ 🔊  Hund      собака     [Удалить]                        │   │
│  │ 🖼️ 🔊  Katze     кошка      [Удалить]                        │   │
│  └──────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### Иконки наличия медиа

В списке слов показывать иконки:
- 🖼️ — есть изображение
- 🔊 — есть аудио
- ⚠️ — медиа отсутствует (можно перегенерировать)

### Чек-лист

- [ ] В редакторе колоды есть настройки генерации медиа
- [ ] Чекбокс "Генерировать изображения" работает
- [ ] Чекбокс "Генерировать аудио" работает
- [ ] Селектор стиля изображений работает
- [ ] При добавлении слова вызывается `/api/media/generate-image/`
- [ ] При добавлении слова вызывается `/api/media/generate-audio/`
- [ ] Индикатор генерации показывается
- [ ] Форма заблокирована во время генерации
- [ ] URL медиа передаются в `add_words`
- [ ] Слово сохраняется с `image_file` и `audio_file`
- [ ] В списке слов видны иконки наличия медиа
- [ ] При экспорте колоды в `.apkg` — медиа присутствует
- [ ] Время добавления 1 слова ~10-15 секунд (ожидаемо)
- [ ] Массовое добавление работает последовательно

---

## Этап 13.6: Сохранение быстрой генерации в "Мои колоды"

**Цель:** Добавить возможность сохранить колоду из быстрой генерации в "Мои колоды" для последующего редактирования.

**Проблема:** Сейчас быстрая генерация создаёт только `.apkg` файл для скачивания. Колода НЕ сохраняется в "Мои колоды", и пользователь не может:
- Добавить ещё слова позже
- Перегенерировать с другими настройками
- Увидеть историю своих колод

**Ориентировочное время:** 1 день

### Задачи

1. Добавить чекбокс на страницу быстрой генерации:
   ```
   ☑️ Сохранить в "Мои колоды"
   ```
   - Расположение: рядом с полем "Название колоды"
   - По умолчанию: включён
   - Подсказка (tooltip): "Колода будет доступна для редактирования в разделе 'Мои колоды'"

2. Обновить логику генерации:
   ```typescript
   const handleGenerate = async () => {
     // ... генерация медиа ...
     
     // Генерация .apkg
     const response = await api.post('/cards/generate/', {
       words: [...],
       translations: {...},
       language: 'de',
       deck_name: deckName,
       image_files: {...},
       audio_files: {...},
       save_to_decks: saveToDecks,  // ← Новый параметр!
     });
     
     // Скачать файл
     downloadFile(response.data.file_id);
     
     // Если сохранено — показать уведомление
     if (saveToDecks) {
       showSuccess(`Колода "${deckName}" сохранена в "Мои колоды"`);
     }
   };
   ```

3. Добавить ссылку после генерации:
   - Если `saveToDecks: true`, показать:
     ```
     ✅ Файл скачан! 
     Колода сохранена. [Открыть в редакторе →]
     ```
   - Ссылка ведёт на `/decks/{созданный_id}`

4. Обновить бэкенд (если нужно):
   - API `/cards/generate/` должен принимать параметр `save_to_decks`
   - Если `true` — создавать `Deck` со словами
   - Возвращать `deck_id` в ответе

### Схема работы

```
┌─────────────────────────────────────────────────────────────────────┐
│  Быстрая генерация                                                  │
│                                                                     │
│  Название колоды: [Животные____________]                            │
│  ☑️ Сохранить в "Мои колоды"                                        │
│                                                                     │
│  [Сгенерировать карточки]                                           │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│  Результат:                                                         │
│                                                                     │
│  ✅ Файл "Животные.apkg" скачан!                                    │
│                                                                     │
│  📁 Колода сохранена в "Мои колоды"                                 │
│     [Открыть в редакторе →]  [Перейти в Мои колоды →]              │
└─────────────────────────────────────────────────────────────────────┘
```

### Изменения в API (для бэкенда)

Нужно обновить `POST /api/cards/generate/`:

**Новый параметр запроса:**
```json
{
  "words": [...],
  "translations": {...},
  "language": "de",
  "deck_name": "Животные",
  "image_files": {...},
  "audio_files": {...},
  "save_to_decks": true  // ← НОВОЕ
}
```

**Обновлённый ответ:**
```json
{
  "file_id": "uuid-xxx",
  "deck_id": 42  // ← НОВОЕ (только если save_to_decks: true)
}
```

### Чек-лист

- [ ] Чекбокс "Сохранить в Мои колоды" добавлен
- [ ] Чекбокс включён по умолчанию
- [ ] Tooltip с подсказкой отображается
- [ ] При `saveToDecks: true` — колода создаётся в "Мои колоды"
- [ ] При `saveToDecks: false` — только скачивание, без сохранения
- [ ] После генерации показывается ссылка на редактор (если сохранено)
- [ ] Клик на ссылку ведёт в редактор колоды
- [ ] Колода видна в списке "Мои колоды"
- [ ] Слова в колоде соответствуют сгенерированным
- [ ] Уведомление о сохранении отображается

---

## Этап 14: Предпросмотр медиа

**Цель:** Добавить возможность предпросмотра сгенерированных изображений и прослушивания аудио. После этого этапа пользователь может увидеть/услышать медиа до скачивания.

**Ориентировочное время:** 1-2 дня

### Задачи

1. Создать модальное окно предпросмотра изображения:
   - Полноразмерное изображение
   - Кнопка закрытия
   - Название слова

2. Создать компонент аудио-плеер:
   - Кнопка play/pause
   - Прогресс воспроизведения
   - Компактный дизайн для встраивания в таблицу

3. Обновить TranslationTable:
   - При клике на индикатор изображения — открыть модальное окно
   - При клике на индикатор аудио — воспроизвести/остановить

4. Отдельная генерация медиа (опционально):
   - Кнопка "Перегенерировать" рядом с медиа
   - Позволяет заново сгенерировать изображение/аудио для конкретного слова

### Чек-лист

- [ ] Модальное окно изображения создано
- [ ] При клике на индикатор изображения открывается модальное окно
- [ ] Изображение отображается в полном размере
- [ ] Модальное окно можно закрыть
- [ ] Аудио-плеер создан
- [ ] При клике на индикатор аудио воспроизводится звук
- [ ] Можно остановить воспроизведение
- [ ] Плеер отображает прогресс
- [ ] Кнопка "Перегенерировать" работает (опционально)

---

## Этап 15: Обработка ошибок

**Цель:** Создать систему обработки всех типов ошибок с понятными сообщениями для пользователя. После этого этапа приложение gracefully обрабатывает все ошибки.

**Ориентировочное время:** 1-2 дня

### Задачи

1. Создать компонент `ErrorBoundary`:
   - Оборачивает все приложение
   - При crash — показывает страницу ошибки
   - Кнопка "Перезагрузить страницу"

2. Создать страницу 404 (`NotFoundPage.tsx`):
   - Сообщение "Страница не найдена"
   - Кнопка "На главную"

3. Создать страницу 500 (`ErrorPage.tsx`):
   - Сообщение "Что-то пошло не так"
   - Кнопка "Попробовать снова"

4. Обработка HTTP ошибок в API клиенте:
   - 400: показать сообщение из ответа
   - 401: очистить токен, редирект на login
   - 403: показать "Нет доступа"
   - 404: показать "Не найдено"
   - 500: показать "Ошибка сервера"
   - Timeout: показать "Превышено время ожидания"
   - Network error: показать "Нет подключения к серверу"

5. Валидационные ошибки:
   - Отображать под соответствующими полями
   - Красный текст, иконка ошибки

### Чек-лист

- [ ] ErrorBoundary создан и оборачивает приложение
- [ ] При crash показывается fallback UI
- [ ] Страница 404 отображается при неверном маршруте
- [ ] Страница 500 создана
- [ ] Ошибка 400 показывает понятное сообщение
- [ ] Ошибка 401 редиректит на login
- [ ] Ошибка 403 показывает "Нет доступа"
- [ ] Ошибка 404 (API) показывает "Не найдено"
- [ ] Ошибка 500 показывает "Ошибка сервера"
- [ ] Ошибка сети показывает "Нет подключения"
- [ ] Валидационные ошибки отображаются под полями
- [ ] Приложение не падает при любых ошибках

---

## Этап 16: UX полировка и анимации

**Цель:** Улучшить пользовательский опыт с помощью skeleton loaders, анимаций и плавных переходов. После этого этапа приложение выглядит отполированным и профессиональным.

**Ориентировочное время:** 2 дня

### Задачи

1. Создать компоненты Skeleton:
   - `DeckCardSkeleton` — для списка колод
   - `WordsTableSkeleton` — для таблицы слов
   - `ProfileSkeleton` — для страницы профиля

2. Внедрить Skeleton loaders:
   - Страница колод: показывать скелетоны во время загрузки
   - Редактор колоды: скелетон для списка слов
   - Профиль: скелетон для формы

3. Добавить анимации переходов:
   - Установить Framer Motion или использовать CSS transitions
   - Плавное появление страниц
   - Анимация появления элементов списка

4. Микро-анимации:
   - Hover эффекты на кнопках
   - Плавное появление/исчезновение модальных окон
   - Анимация переключателей

5. Debounce для поиска/фильтрации:
   - В полях ввода (если есть поиск)
   - Оптимизация частых запросов

6. Lazy loading изображений:
   - Использовать loading="lazy"
   - Placeholder пока изображение загружается

### Чек-лист

- [ ] Skeleton компоненты созданы
- [ ] На странице колод показываются скелетоны при загрузке
- [ ] В редакторе колоды скелетон для слов
- [ ] На странице профиля скелетон при загрузке
- [ ] Страницы появляются с плавной анимацией
- [ ] Элементы списка появляются с stagger эффектом
- [ ] Hover эффекты на всех интерактивных элементах
- [ ] Модальные окна открываются/закрываются плавно
- [ ] Переключатели анимированы
- [ ] Изображения загружаются лениво
- [ ] Интерфейс отзывчив на всех устройствах

---

## Этап 17: Оптимизация и финальное тестирование

**Цель:** Оптимизировать производительность приложения и провести финальное тестирование всех функций. После этого этапа приложение готово к production.

**Ориентировочное время:** 2 дня

### Задачи

1. Code splitting:
   - Разделить код по маршрутам
   - Использовать React.lazy() для страниц
   - Suspense с fallback

2. Lazy loading маршрутов:
   ```typescript
   const LoginPage = lazy(() => import('./pages/LoginPage'));
   const DecksPage = lazy(() => import('./pages/DecksPage'));
   // и т.д.
   ```

3. Мемоизация:
   - React.memo() для тяжелых компонентов
   - useMemo() для вычислений
   - useCallback() для обработчиков событий

4. Оптимизация ре-рендеров:
   - Проверить DevTools Profiler
   - Убрать лишние ре-рендеры
   - Оптимизировать контексты (разделить на мелкие)

5. Финальное тестирование:
   - Проверить все User Flow
   - Проверить на разных браузерах
   - Проверить на мобильных устройствах
   - Проверить dark mode везде

6. Сборка production:
   - `npm run build`
   - Проверить размер бандла
   - Проверить работу собранного приложения

### Чек-лист

- [ ] Code splitting настроен для маршрутов
- [ ] Lazy loading работает (видно в Network)
- [ ] Suspense показывает fallback при загрузке
- [ ] Мемоизация применена где нужно
- [ ] React DevTools Profiler не показывает лишних ре-рендеров
- [ ] Приложение работает в Chrome
- [ ] Приложение работает в Firefox
- [ ] Приложение работает в Safari
- [ ] Приложение работает на мобильных устройствах
- [ ] Dark mode работает на всех страницах
- [ ] `npm run build` выполняется без ошибок
- [ ] Размер бандла разумный (< 500KB gzipped)
- [ ] Production сборка работает корректно

---

## Этап 18: Режимы работы Simple/Advanced (опционально)

> ⚠️ **Примечание:** Этот этап является опциональным и может быть исключён из плана в зависимости от приоритетов. Реализуйте его только если есть время и ресурсы.

**Цель:** Реализовать два режима работы: простой (автоматический) и расширенный (ручной). После этого этапа пользователь может выбрать удобный способ создания карточек.

**Ориентировочное время:** 2 дня

### Задачи

1. Добавить переключатель режима:
   - Расположение: в Header или на странице профиля
   - Два состояния: "Простой" / "Расширенный"
   - Сохранение в профиле пользователя (поле `mode`)

2. Простой режим (Simple Mode):
   - Только одно большое поле ввода слов
   - Одна кнопка "Создать карточки"
   - Скрыты: таблица переводов, выбор языка, выбор стиля, название колоды
   - Все определяется автоматически

3. Анимация процесса генерации в простом режиме:
   - Этапы: "Анализируем слова...", "Придумываем название...", "Генерируем картинки...", "Создаем файл..."
   - Плавная анимация перехода между этапами
   - Прогресс-индикатор

4. Расширенный режим (Advanced Mode):
   - Все элементы видны как было
   - Полный контроль над настройками

5. Обновить API запрос:
   - В простом режиме бэкенд автоматически определяет название, категорию и стиль

### Чек-лист

- [ ] Переключатель режима отображается
- [ ] Переключение работает мгновенно
- [ ] В простом режиме отображается только поле ввода и кнопка
- [ ] Таблица переводов скрыта в простом режиме
- [ ] Настройки языка/стиля скрыты в простом режиме
- [ ] При генерации в простом режиме показываются этапы
- [ ] Анимация этапов работает плавно
- [ ] В расширенном режиме все элементы видны
- [ ] Режим сохраняется в профиле на сервере
- [ ] При перезагрузке режим восстанавливается
- [ ] Кнопка генерации адаптируется к режиму

---

## Финальный чек-лист

Перед сдачей проекта убедитесь, что:

### Функциональность

- [ ] Регистрация работает
- [ ] Вход работает
- [ ] Выход работает
- [ ] Профиль загружается и редактируется
- [ ] Аватар загружается и удаляется
- [ ] Тема переключается и сохраняется
- [ ] Колоды создаются
- [ ] Колоды редактируются
- [ ] Колоды удаляются
- [ ] Слова добавляются в колоду
- [ ] Слова удаляются из колоды
- [ ] Генерация из колоды работает
- [ ] Быстрая генерация работает
- [ ] Выбор стиля изображений работает
- [ ] Выбор провайдера генерации изображений работает (OpenAI/Gemini)
- [ ] Выбор модели Gemini работает (Flash/Pro)
- [ ] Дробные токены отображаются корректно (0.5, 1.5 и т.д.)
- [ ] Чекбоксы медиа работают
- [ ] Автоперевод работает
- [ ] Автокоррекция немецкого работает
- [ ] Токены отображаются
- [ ] Блокировка при нулевом балансе работает
- [ ] Файлы .apkg скачиваются

### Качество

- [ ] Нет ошибок в консоли
- [ ] Все TypeScript типы корректны
- [ ] Код форматирован (Prettier)
- [ ] ESLint не выдает ошибок
- [ ] Все компоненты имеют понятные имена
- [ ] Комментарии где нужно
- [ ] README с инструкцией по запуску

---

## API Reference

### Base URL
```
http://localhost:8000/api/
```

### Авторизация
Все защищенные endpoints требуют заголовок:
```
Authorization: Token <your-token>
```

### Endpoints

| Метод | URL | Описание |
|-------|-----|----------|
| POST | `/auth/register/` | Регистрация |
| POST | `/auth/login/` | Вход |
| GET | `/user/profile/` | Получить профиль |
| PATCH | `/user/profile/` | Обновить профиль |
| GET | `/tokens/balance/` | Баланс токенов |
| GET | `/tokens/transactions/` | История транзакций |
| GET | `/cards/decks/` | Список колод |
| POST | `/cards/decks/` | Создать колоду |
| GET | `/cards/decks/{id}/` | Получить колоду |
| PATCH | `/cards/decks/{id}/` | Обновить колоду |
| DELETE | `/cards/decks/{id}/` | Удалить колоду |
| POST | `/cards/decks/{id}/add_words/` | Добавить слова |
| POST | `/cards/decks/{id}/remove_word/` | Удалить слово |
| POST | `/cards/decks/{id}/generate_apkg/` | Генерация из колоды |
| POST | `/cards/generate/` | Быстрая генерация |
| GET | `/cards/download/{file_id}/` | Скачать файл |
| POST | `/cards/analyze-words/` | Анализ слов |
| POST | `/cards/translate-words/` | Перевод слов |
| POST | `/cards/process-german-words/` | Обработка немецких слов |
| POST | `/media/generate-image/` | Генерация изображения (поддерживает `provider` и `gemini_model`) |
| POST | `/media/generate-audio/` | Генерация аудио |

---

**Удачи в разработке! 🚀**
